Read below file carefully line by line.

error- Uncaught TypeError: Cannot convert undefined or null to object
    at Object.entries (<anonymous>)
    at pingAllDevices (script.js:433:41)
    at script.js:399:9

also When Device goes offline again its back online Count in Summary Section is not Updated.
Also When Deive filter using City count of offline Device displays in online count section.

Also Total cameras count
Total online Cameras count
Total Offline Cameras count
same for Archiver , Controller, Server is not displaying it shows only Total decice count and Online offline count.

Kindly check all file line by line and give me Updated Script.js




const baseUrl = "http://localhost:80/api/regions";
let refreshInterval = 300000; // 5 minutes
let pingInterval = 30000; // 30 seconds
let countdownTime = refreshInterval / 1000; // Convert to seconds
let currentRegion = "global"; 
let deviceDetailsCache = {}; // Store previous details to prevent redundant updates

document.addEventListener("DOMContentLoaded", () => {
    fetchData("global"); // Load initial data
    startAutoRefresh("global");

    document.querySelectorAll(".region-button").forEach((button) => {
        button.addEventListener("click", () => {
            const region = button.getAttribute("data-region");
            document.getElementById("region-title").textContent = `${region.toUpperCase()} Summary`;
            switchRegion(region);
        });
    });

    document.getElementById("close-modal").addEventListener("click", () => {
        document.getElementById("modal").style.display = "none";
    });
});




function switchRegion(region) {
    clearExistingIntervals(); // Avoid interval duplication
    currentRegion = region; 
    deviceDetailsCache={};
    fetchData(region);
    startAutoRefresh(region);
}

// **Auto-refresh mechanism**
function startAutoRefresh(regionName) {
    fetchData(regionName); // Fetch initial data

    clearExistingIntervals();

    // Start countdown timer
    window.countdownTimer = setInterval(() => {
        document.getElementById("countdown").innerText = `Refreshing in ${countdownTime} seconds`;
        countdownTime--;
        if (countdownTime < 0) countdownTime = refreshInterval / 1000;
    }, 1000);

    // Refresh summary & details every 5 minutes
    window.refreshTimer = setInterval(() => {
        fetchData(regionName);
        countdownTime = refreshInterval / 1000;
    }, refreshInterval);

    // Ping devices every 30 seconds
    window.pingTimer = setInterval(() => {
        pingAllDevices(regionName);
    }, pingInterval);
}

function clearExistingIntervals() {
    clearInterval(window.countdownTimer);
    clearInterval(window.refreshTimer);
    clearInterval(window.pingTimer);
}

// **Fetch summary and details together**
function fetchData(regionName) {
    Promise.all([
        fetch(`${baseUrl}/summary/${regionName}`).then(res => res.json()),
        fetch(`${baseUrl}/details/${regionName}`).then(res => res.json())
    ])
    .then(([summary, details]) => {
        console.log("Summary Data:", summary);
        console.log("Details Data:", details);

        updateSummary(summary);
        
        if (JSON.stringify(details) !== JSON.stringify(deviceDetailsCache)) {
            updateDetails(details);
            deviceDetailsCache = details; // Update cache
        }
    })
    .catch((error) => console.error("Error fetching data:", error));
}


function pingAllDevices(details, regionName) {
    let statusChanged = false; // Track if any status changed

    for (const [key, devices] of Object.entries(details.details)) {
        if (!Array.isArray(devices) || devices.length === 0) continue;

        devices.forEach((device) => {
            const ip = device.ip_address || "N/A";
            const card = document.querySelector(`[data-ip="${ip}"]`);

            if (!card) return; // If device is not found in UI, skip

            // Ping the device API
            fetch(`${baseUrl}/ping/${ip}`)
                .then(response => response.json())
                .then(statusData => {
                    const newStatus = statusData.status.toLowerCase(); // Get live status
                    const currentStatus = card.dataset.status; // Current status in UI

                    // Update the UI instantly
                    const statusDot = card.querySelector(".status-dot");
                    const statusText = card.querySelector(".device-status");

                    if (newStatus === "online") {
                        statusDot.style.backgroundColor = "green";
                        statusText.textContent = "Online";
                    } else {
                        statusDot.style.backgroundColor = "red";
                        statusText.textContent = "Offline";
                    }

                    if (newStatus !== currentStatus) {
                        statusChanged = true; // A change in status was detected
                        card.dataset.status = newStatus; // Update dataset
                    }
                })
                .catch(error => console.error(`Ping failed for ${ip}:`, error));
        });
    }

    // After processing all devices, if any status changed, refresh summary
    setTimeout(() => {
        if (statusChanged) {
            fetchData(regionName);
        }
    }, 5000); // Small delay to ensure all pings are processed
}

// setInterval(() => {
//     pingAllDevices(data.details, regionName);
// }); 




function updateSummary(data) {

    document.getElementById("total-devices").textContent = data.summary?.totalDevices || "0";
    document.getElementById("online-devices").textContent = data.summary?.totalOnlineDevices || "0";
    document.getElementById("offline-devices").textContent = data.summary?.totalOfflineDevices || "0";

    document.getElementById("camera-total").textContent = data.summary?.cameras?.total || "0";
    document.getElementById("camera-online").textContent = data.summary?.cameras?.online || "0";
    document.getElementById("camera-offline").textContent = data.summary?.cameras?.offline || "0";

    document.getElementById("archiver-total").textContent = data.summary?.archivers?.total || "0";
    document.getElementById("archiver-online").textContent = data.summary?.archivers?.online || "0";
    document.getElementById("archiver-offline").textContent = data.summary?.archivers?.offline || "0";

    document.getElementById("controller-total").textContent = data.summary?.controllers?.total || "0";
    document.getElementById("controller-online").textContent = data.summary?.controllers?.online || "0";
    document.getElementById("controller-offline").textContent = data.summary?.controllers?.offline || "0";

    document.getElementById("server-total").textContent = data.summary?.servers?.total || "0";
    document.getElementById("server-online").textContent = data.summary?.servers?.online || "0";
    document.getElementById("server-offline").textContent = data.summary?.servers?.offline || "0";

}


function updateDetails(data) {
    const detailsContainer = document.getElementById("device-details");
    const deviceFilter = document.getElementById("device-filter");
    const onlineFilterButton = document.getElementById("filter-online");
    const offlineFilterButton = document.getElementById("filter-offline");
    const allFilterButton = document.getElementById("filter-all");
    const cityFilter = document.getElementById("city-filter");



    detailsContainer.innerHTML = ""; // Clear previous data

   
    // detailsContainer.innerHTML = "";
    cityFilter.innerHTML = '<option value="all">All Cities</option>';

    let allDevices = [];
    let deviceObjects = []; // [UPDATED] for city-wise summary
    let citySet = new Set();
    


 // Fetch real-time status from the backend
    fetch("http://localhost:80/api/region/devices/status")
        .then((response) => response.json())
        .then((realTimeStatus) => {
            console.log("Live Status Data:", realTimeStatus);

            for (const [key, devices] of Object.entries(data.details)) {
                if (!Array.isArray(devices) || devices.length === 0) continue;

                const deviceType = key.toLowerCase();

                devices.forEach((device) => {

                    allDevices.sort((a, b) => {
                        const statusA = a.dataset.status === "offline" ? 0 : 1;
                        const statusB = b.dataset.status === "offline" ? 0 : 1;
                        return statusA - statusB;
                    });
                    
            
                    const deviceIP = device.ip_address || "N/A";
                    const currentStatus = realTimeStatus[deviceIP] || device.status;
                    const city = device.city || "Unknown";

                    citySet.add(city);

                    const card = document.createElement("div");
                    card.className = "device-card";
                    card.dataset.type = deviceType;
                    card.dataset.status = currentStatus.toLowerCase();
                    card.dataset.city = city;

                    const statusDot = document.createElement("span");
                    statusDot.className = "status-dot";
                    statusDot.style.backgroundColor = currentStatus === "Online" ? "green" : "red";

                    card.innerHTML = `
                        <h3>${device.cameraname || device.controllername || device.archivername || device.servername || "Unknown Device"}</h3>
                        <p>DEVICE TYPE: ${deviceType.toUpperCase()}</p>
                        <p>IP: ${deviceIP}</p>
                        <p>LOCATION: ${device.location || "N/A"}</p>
                        <p>CITY: ${city}</p>
                        <p>Status: ${currentStatus} ${statusDot.outerHTML}</p>
                        <button class="details-button" onclick="showModal('${device.cameraname || device.controllername || device.archivername || device.servername || "Unknown Device"}', '${deviceIP}', '${device.location || "N/A"}', '${currentStatus}', '${city}')">Details</button>
                    `;

                    allDevices.push(card);

                    // [UPDATED]: Push raw device data for summary
                    deviceObjects.push({
                        type: deviceType,
                        status: currentStatus.toLowerCase(),
                    });
                });
            }

            citySet.forEach((city) => {
                const option = document.createElement("option");
                option.value = city;
                option.textContent = city;
                cityFilter.appendChild(option);
            });

            deviceFilter.value = "all";
            cityFilter.value = "all";
            document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
            allFilterButton.classList.add("active");
            


            function filterDevices() {
                const selectedType = deviceFilter.value;
                const selectedStatus = document.querySelector(".status-filter.active")?.dataset.status || "all";
                const selectedCity = cityFilter.value;
            
                detailsContainer.innerHTML = "";
            
                const filteredDevices = allDevices.filter((device) =>
                    (selectedType === "all" || device.dataset.type === selectedType) &&
                    (selectedStatus === "all" || device.dataset.status === selectedStatus) &&
                    (selectedCity === "all" || device.dataset.city === selectedCity)
                );
            
                filteredDevices.forEach((deviceCard) => {
                    detailsContainer.appendChild(deviceCard);
                });
            

                // Update Summary Title
                const region = currentRegion?.toUpperCase() || "GLOBAL";
                if (selectedCity !== "all") {
                    document.getElementById("region-title").textContent = `${region}, ${selectedCity} Summary`;
                } else {
                    document.getElementById("region-title").textContent = `${region} Summary`;
                }


            
                // [UPDATED]: Recalculate city-wise summary
                const filteredSummaryDevices = deviceObjects.filter((deviceCard, index) => {
                    const element = allDevices[index];
                    return (
                        (selectedType === "all" || element.dataset.type === selectedType) &&
                        (selectedStatus === "all" || element.dataset.status === selectedStatus) &&
                        (selectedCity === "all" || element.dataset.city === selectedCity)
                    );
                });
            
                const summary = calculateCitySummary(filteredSummaryDevices);
                updateSummary(summary);
            }
            
            
            // [UPDATED]: Calculate summary from filtered list
            function calculateCitySummary(devices) {
                const summary = {
                    summary: {
                        totalDevices: devices.length,
                        totalOnlineDevices: devices.filter(d => d.status === "online").length,
                        totalOfflineDevices: devices.filter(d => d.status === "offline").length,
                        cameras: { total: 0, online: 0, offline: 0 },
                        archivers: { total: 0, online: 0, offline: 0 },
                        controllers: { total: 0, online: 0, offline: 0 },
                        servers: { total: 0, online: 0, offline: 0 },
                    }
                };

                devices.forEach((device) => {

                    if (!summary.summary[device.type + "s"]) return;
                    summary.summary[device.type + "s"].total += 1;
                    if (device.status === "online") summary.summary[device.type + "s"].online += 1;
                    else summary.summary[device.type + "s"].offline += 1;
                });

                return summary;
            }

            // Initial Display
            filterDevices();


            setTimeout(() => {
                const selectedCity = cityFilter.value;
                const selectedType = deviceFilter.value;
                const selectedStatus = document.querySelector(".status-filter.active")?.dataset.status || "all";

                const filteredSummaryDevices = deviceObjects.filter((deviceCard, index) => {
                    const element = allDevices[index];
                    return (
                        (selectedType === "all" || element.dataset.type === selectedType) &&
                        (selectedStatus === "all" || element.dataset.status === selectedStatus) &&
                        (selectedCity === "all" || element.dataset.city === selectedCity)
                    );
                });

                const summary = calculateCitySummary(filteredSummaryDevices);
                updateSummary(summary);
            }, 100); // Add slight delay to ensure DOM update is done



            deviceFilter.addEventListener("change", filterDevices);
            cityFilter.addEventListener("change", filterDevices);
            allFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                allFilterButton.classList.add("active");
                filterDevices();
            });
            onlineFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                onlineFilterButton.classList.add("active");
                filterDevices();
            });
            offlineFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                offlineFilterButton.classList.add("active");
                filterDevices();
            });

        })
        .catch((error) => {
            console.error("Error fetching real-time device status:", error);
            detailsContainer.innerHTML = "<p>Failed to load device details.</p>";
        });
}


    function showModal(name, ip, location, status) {
        document.getElementById("modal-title").textContent = `Details for ${name}`;
        document.getElementById("modal-body").innerHTML = `
            <li><strong>Name:</strong> ${name}</li>
            <li><strong>IP:</strong> ${ip}</li>
            <li><strong>Location:</strong> ${location}</li>

            <li><strong>Status:</strong> ${status}</li>
        `;
        document.getElementById("modal").style.display = "block";
    }
