require("dotenv").config();
const express = require("express");
const cors = require("cors");
const bodyParser = require("body-parser");
const regionRoutes = require("./routes/regionRoutes");
const ping = require("ping");
const moment = require("moment-timezone");

const app = express();
const PORT = process.env.PORT || 80;

const { fetchAllIpAddress } = require("./services/excelService");

// Middleware
app.use(
  cors({
    origin: "http://127.0.0.1:5501",
    methods: "GET,POST,PUT,DELETE",
    allowedHeaders: "Content-Type,Authorization",
  })
);
app.use(bodyParser.json());

// Routes
app.use("/api/regions", regionRoutes);

// ✅ Keep your existing API endpoints as they are

// Ping a specific device dynamically
app.get("/api/ping/:ip", async (req, res) => {
  const ip = req.params.ip;
  
  try {
    const result = await ping.promise.probe(ip);
    res.json({ ip, status: result.alive ? "Online" : "Offline" });
  } catch (error) {
    console.error(`Ping error for ${ip}:`, error);
    res.json({ ip, status: "Offline" });
  }
});

// Function to continuously ping all devices
const devices = fetchAllIpAddress();
let deviceStatus = {};

async function pingDevices() {
  for (const ip of devices) {
    try {
      const result = await ping.promise.probe(ip);
      deviceStatus[ip] = result.alive ? "Online" : "Offline";
    } catch (error) {
      console.error(`Error pinging ${ip}:`, error);
      deviceStatus[ip] = "Offline";
    }
  }
  console.log("Updated device status:", deviceStatus);
}

// Ping devices every 30 seconds
setInterval(pingDevices, 30000);

// Get real-time status of all devices
app.get("/api/devices/status", (req, res) => {
  res.json(deviceStatus);
});

// ✅ New Endpoint: Retrieve downtime & uptime stats
let deviceHistory = new Map();

const storeStatusHistory = (ip, status) => {
  const now = moment().tz("Asia/Kolkata");
  const currentDate = now.format("YYYY-MM-DD");
  const currentWeek = now.week();
  const currentMonth = now.month() + 1;

  let currentDevice = deviceHistory.get(ip) || {
    lastOnline: null,
    lastOffline: null,
    history: {
      day: {},
      week: {},
      month: {},
    },
  };

  let history = currentDevice.history;

  if (!history.day[currentDate]) {
    history.day[currentDate] = { uptime: 0, downtime: 0, downtimeDuration: 0 };
  }
  if (!history.week[currentWeek]) {
    history.week[currentWeek] = { uptime: 0, downtime: 0, downtimeDuration: 0 };
  }
  if (!history.month[currentMonth]) {
    history.month[currentMonth] = { uptime: 0, downtime: 0, downtimeDuration: 0 };
  }

  if (status === "Online") {
    if (currentDevice.lastOffline) {
      const downtimeDuration = now.diff(moment(currentDevice.lastOffline), "seconds");
      history.day[currentDate].downtimeDuration += downtimeDuration;
      history.week[currentWeek].downtimeDuration += downtimeDuration;
      history.month[currentMonth].downtimeDuration += downtimeDuration;
      history.day[currentDate].downtime++;
      history.week[currentWeek].downtime++;
      history.month[currentMonth].downtime++;
    }
    history.day[currentDate].uptime++;
    history.week[currentWeek].uptime++;
    history.month[currentMonth].uptime++;
    currentDevice.lastOnline = now.toDate();
    currentDevice.lastOffline = null;
  } else {
    if (!currentDevice.lastOffline) {
      currentDevice.lastOffline = now.toDate();
    }
    history.day[currentDate].downtime++;
    history.week[currentWeek].downtime++;
    history.month[currentMonth].downtime++;
  }

  deviceHistory.set(ip, currentDevice);
};

// Track status changes
setInterval(() => {
  for (const ip of devices) {
    const status = deviceStatus[ip] || "Offline";
    storeStatusHistory(ip, status);
  }
}, 30000);

// Endpoint to fetch downtime & uptime stats
app.get("/api/devices/downtime-uptime", (req, res) => {
  const response = {};
  deviceHistory.forEach((data, ip) => {
    response[ip] = {
      daily: data.history.day,
      weekly: data.history.week,
      monthly: data.history.month,
    };
  });
  res.json(response);
});

// Error handling
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).send("Internal Server Error");
});

// Start server
app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`);
  pingDevices();
});
