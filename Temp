function openDeviceHistory(deviceIp, deviceName) {
    if (!window.deviceHistoryData) {
        console.error("Device history data not loaded.");
        return;
    }
    const history = window.deviceHistoryData[deviceIp] || [];
    displayDeviceHistory(deviceIp, deviceName, history);
    document.getElementById('device-history-modal').style.display = 'block';
}



function displayDeviceHistory(deviceIp, deviceName, history) {
    const modalHeader = document.getElementById('device-history-header');
    const historyContainer = document.getElementById('device-history');

    // Set the device name and IP in the header
    modalHeader.innerHTML = `
        <h3>Device History</h3>
        <p><strong>Device Name:</strong> ${deviceName}</p>
        <p><strong>Device IP:</strong> ${deviceIp}</p>
        <button onclick="closeHistoryModal()" style="float:right; padding: 5px 10px; background-color: red; color: white; border: none; cursor: pointer;">Close</button>
        <hr>
    `;

    historyContainer.innerHTML = ''; // Clear previous history data

    if (history.length > 0) {
        let lastOfflineTime = null;

        for (let i = 0; i < history.length; i++) {
            const entry = history[i];
            const date = new Date(entry.timestamp);
            const formattedDate = date.toDateString();
            const day = date.toLocaleDateString(undefined, { weekday: 'long' });
            const time = date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit' });

            let downtimeText = '';

            if (lastOfflineTime && entry.status === "Online") {
                const downtimeSeconds = Math.floor((date - lastOfflineTime) / 1000);
                downtimeText = `<span style="color: red;"> (Downtime: ${formatDuration(downtimeSeconds)})</span>`;
                lastOfflineTime = null;
            }

            if (entry.status === "Offline") {
                lastOfflineTime = date;
            }

            const entryDiv = document.createElement('div');
            entryDiv.innerHTML = `<p><strong>${day}, ${formattedDate}, ${time}</strong> - ${entry.status} ${downtimeText}</p>`;

            historyContainer.appendChild(entryDiv);
        }
    } else {
        historyContainer.innerHTML = '<p>No history available</p>';
    }
}



<td><button onclick="openDeviceHistory('${deviceIp}', '${deviceName}')">View History</button></td>





<div id="device-history-modal" style="display:none; position:fixed; top:20%; left:30%; width:40%; background:white; padding:20px; box-shadow: 0 0 10px rgba(0,0,0,0.5);">
    <div id="device-history-header"></div> <!-- Header for Device Name and IP -->
    <div id="device-history"></div> <!-- Device history details -->
</div>












function displayDeviceHistory(history) {
    const historyContainer = document.getElementById('device-history');
    historyContainer.innerHTML = ''; // Clear existing content

    if (history.length === 0) {
        historyContainer.innerHTML = '<p>No history available</p>';
        return;
    }

    // Create table
    const table = document.createElement('table');
    table.style.width = '100%';
    table.style.borderCollapse = 'collapse';

    // Create table headers
    const headerRow = table.insertRow();
    ['Date', 'Day', 'Time', 'Status', 'Downtime Duration'].forEach(headerText => {
        const th = document.createElement('th');
        th.innerText = headerText;
        th.style.border = '1px solid black';
        th.style.padding = '5px';
        th.style.backgroundColor = '#f2f2f2';
        table.appendChild(headerRow);
        headerRow.appendChild(th);
    });

    let lastOfflineTime = null; // Track the last offline timestamp

    history.forEach(entry => {
        const date = new Date(entry.timestamp);
        const formattedDate = date.toLocaleDateString();
        const day = date.toLocaleDateString(undefined, { weekday: 'long' });
        const time = date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit' });

        let downtimeText = '-'; // Default for online entries

        // Calculate downtime when transitioning from Offline â†’ Online
        if (lastOfflineTime && entry.status === "Online") {
            const downtimeSeconds = Math.floor((date - lastOfflineTime) / 1000);
            downtimeText = formatDuration(downtimeSeconds);
            lastOfflineTime = null; // Reset
        }

        if (entry.status === "Offline") {
            lastOfflineTime = date;
        }

        // Create row
        const row = table.insertRow();
        [formattedDate, day, time, entry.status, downtimeText].forEach((text, index) => {
            const cell = row.insertCell(index);
            cell.innerText = text;
            cell.style.border = '1px solid black';
            cell.style.padding = '5px';
            if (index === 3) cell.style.color = entry.status === "Offline" ? 'red' : 'green';
        });

    });

    historyContainer.appendChild(table);
}














Read carefully Trend.js file

i want to Display device history in table format.
update my file as per my requirnment.

let deviceUptimeTimers = {};
let deviceDowntimeTimers = {};

function fetchDeviceData() {
    const selectedRegion = document.getElementById('region').value;
    fetch(`http://localhost/api/regions/details/${selectedRegion}`)
        .then(response => response.json())
        .then(regionData => {
            fetchDeviceHistory(regionData.details);
        })
        .catch(error => console.error('Error fetching device data:', error));
}

function fetchDeviceHistory(regionDetails) {
    fetch(`http://localhost/api/devices/history`)
        .then(response => response.json())
        .then(historyData => {
            populateDeviceTable(regionDetails, historyData);
            window.deviceHistoryData = historyData; // Store history for reuse
        })
        .catch(error => console.error('Error fetching device history:', error));
}


function populateDeviceTable(details, historyData) {
    const tableBody = document.getElementById('device-table').getElementsByTagName('tbody')[0];
    tableBody.innerHTML = ''; // Clear existing rows

    let deviceList = [];

    if (details) {
        ['cameras', 'archivers', 'controllers', 'servers'].forEach(deviceType => {
            details[deviceType]?.forEach(device => {
                const deviceIp = device.ip_address;
                const deviceName = device[deviceType.slice(0, -1) + 'name'];
                const deviceCategory = deviceType.slice(0, -1).toUpperCase();

                const deviceHistory = historyData[deviceIp] || [];
                const lastStatusEntry = deviceHistory.length > 0 ? deviceHistory[deviceHistory.length - 1] : null;
                const currentStatus = lastStatusEntry ? lastStatusEntry.status : "Unknown";

                // Calculate downtime count
                let downtimeCount = deviceHistory.filter(entry => entry.status === "Offline").length;

                // Store device info in an array before rendering
                deviceList.push({
                    deviceIp,
                    deviceName,
                    deviceCategory,
                    currentStatus,
                    deviceHistory,
                    downtimeCount
                });
            });
        });

        // **Sort devices by downtime count (descending order)**
        deviceList.sort((a, b) => b.downtimeCount - a.downtimeCount);

        // **Render sorted devices**
        deviceList.forEach(({ deviceIp, deviceName, deviceCategory, currentStatus, deviceHistory, downtimeCount }) => {
            const row = tableBody.insertRow();
            row.style.border = "1px solid black"; // Add border to row

            row.innerHTML = `
                <td>${deviceIp}</td>
                <td>${deviceName}</td>
                <td>${deviceCategory}</td>
                <td id="uptime-${deviceIp}">0h/0m/0s</td>
                <td id="downtime-count-${deviceIp}">${downtimeCount}</td>
                <td id="downtime-${deviceIp}">0h/0m/0s</td>
                <td><button onclick="openDeviceHistory('${deviceIp}')">View History</button></td>
                <td id="remark-${deviceIp}">Device working properly</td>
            `;

            // Set text color based on status
            const color = currentStatus === "Online" ? "green" : "red";
            row.style.color = color;

            if (currentStatus === "Online") {
                startUptime(deviceIp, deviceHistory);
            } else {
                startDowntime(deviceIp, deviceHistory);
            }

            updateRemarks(deviceIp, deviceHistory, deviceCategory);
        });
    } else {
        console.error('No details found in the response');
    }
}



function startUptime(deviceIp, history) {
    clearInterval(deviceDowntimeTimers[deviceIp]);
    let lastOnlineEntry = history.filter(entry => entry.status === "Online").pop();
    
    if (!lastOnlineEntry) return;
    
    let startTime = new Date(lastOnlineEntry.timestamp).getTime();
    deviceUptimeTimers[deviceIp] = setInterval(() => {
        let elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        document.getElementById(`uptime-${deviceIp}`).innerText = formatDuration(elapsedTime);
    }, 1000);
}

// **Updated startDowntime function to fix current offline detection**
function startDowntime(deviceIp, history) {
    clearInterval(deviceUptimeTimers[deviceIp]);
    let lastOfflineEntry = history.filter(entry => entry.status === "Offline").pop();

    if (!lastOfflineEntry) return;
    
    let startTime = new Date(lastOfflineEntry.timestamp).getTime();
    deviceDowntimeTimers[deviceIp] = setInterval(() => {
        let elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        document.getElementById(`downtime-${deviceIp}`).innerText = formatDuration(elapsedTime);
        updateDowntimeCount(deviceIp, history);
    }, 1000);
}


// **Fix Downtime Count and Remarks Update (with proper filtering)**
function updateDowntimeCount(deviceIp, history) {
    let downtimeEntries = history.filter(entry => entry.status === "Offline");

    // Only count downtimes that last more than 5 minutes, except for servers
    let filteredDowntimeEntries = downtimeEntries.filter((entry, index, arr) => {
        if (deviceType === "SERVER") return true; // Always count downtime for servers
        if (index === 0) return true; // Always keep the first entry

        let previousEntry = arr[index - 1];
        let duration = (new Date(entry.timestamp) - new Date(previousEntry.timestamp)) / 1000;
        return duration >= 300; // 300 seconds = 5 minutes
    });

    let downtimeCount = filteredDowntimeEntries.length;
    
    let downtimeElement = document.getElementById(`downtime-count-${deviceIp}`);
    if (downtimeElement) {
        downtimeElement.innerText = downtimeCount;
    }

    // Update remarks based on downtime count and total downtime
    let remarkElement = document.getElementById(`remark-${deviceIp}`);
    if (remarkElement) {
        if (downtimeCount === 0) {
            remarkElement.innerText = "Device is Online.";
        } else if (downtimeCount >= 3) {
            remarkElement.innerText = `Device is Online, but it had ${downtimeCount} offline occurrences. Needs repair!`;
        } else {
            remarkElement.innerText = `Device is Online, but it had ${downtimeCount} offline occurrences.`;
        }
    }
}



// Fix for updateRemarks function to prioritize current status and handle downtime properly
function updateRemarks(deviceIp, history, deviceType) {
    let downtimeEntries = history.filter(entry => entry.status === "Offline");

    // Filter downtimes that lasted more than 5 minutes (except for servers)
    let filteredDowntimeEntries = downtimeEntries.filter((entry, index, arr) => {
        if (deviceType === "SERVER") return true; // Always count downtime for servers
        if (index === 0) return true; // Always keep the first entry

        let previousEntry = arr[index - 1];
        let duration = (new Date(entry.timestamp) - new Date(previousEntry.timestamp)) / 1000;
        return duration >= 300; // 300 seconds = 5 minutes
    });

    let downtimeCount = filteredDowntimeEntries.length;
    let lastStatus = history.length > 0 ? history[history.length - 1].status : "Unknown";
    let remarkElement = document.getElementById(`remark-${deviceIp}`);
    
    // Calculate total offline duration
    let totalOfflineTime = 0;
    let lastOfflineTime = null;

    history.forEach(entry => {
        if (entry.status === "Offline") {
            if (!lastOfflineTime) lastOfflineTime = new Date(entry.timestamp);
        } else if (entry.status === "Online" && lastOfflineTime) {
            totalOfflineTime += (new Date(entry.timestamp) - lastOfflineTime) / 1000;
            lastOfflineTime = null;
        }
    });

    if (lastOfflineTime) {
        totalOfflineTime += (new Date() - lastOfflineTime) / 1000;
    }

    let totalOfflineDays = Math.floor(totalOfflineTime / 86400); // Convert seconds to days

    // **Condition: Device needs repair if any of the following is true**
    let needsRepair = downtimeCount >= 10 || totalOfflineDays >= 1;

    // **Setting the Correct Remark**
    if (lastStatus === "Offline") {
        if (needsRepair) {
            remarkElement.innerText = "Device is Offline, needs repair.";
        } else {
            remarkElement.innerText = "Device is Offline.";
        }
    } else if (lastStatus === "Online") {
        if (needsRepair) {
            remarkElement.innerText = "Device is Online, needs repair.";
        } else if (downtimeCount > 0) {
            remarkElement.innerText = `Device is Online, it had ${downtimeCount} downtime occurrences.`;
        } else {
            remarkElement.innerText = "Device is Online.";
        }
    } else {
        remarkElement.innerText = "Device status unknown.";
    }

    // **Update Downtime Count in UI**
    let downtimeElement = document.getElementById(`downtime-count-${deviceIp}`);
    if (downtimeElement) {
        downtimeElement.innerText = downtimeCount;
    }
}



function formatDuration(seconds) {
    let days = Math.floor(seconds / 86400); // 1 day = 86400 seconds
    let hours = Math.floor((seconds % 86400) / 3600);
    let minutes = Math.floor((seconds % 3600) / 60);
    let secs = seconds % 60;

    let result = [];
    if (days > 0) result.push(`${days}d`);
    if (hours > 0 || days > 0) result.push(`${hours}h`);
    if (minutes > 0 || hours > 0 || days > 0) result.push(`${minutes}m`);
    result.push(`${secs}s`); // Always show seconds

    return result.join('/');
}



function openDeviceHistory(deviceIp) {
    if (!window.deviceHistoryData) {
        console.error("Device history data not loaded.");
        return;
    }
    const history = window.deviceHistoryData[deviceIp] || [];
    displayDeviceHistory(history);
    document.getElementById('device-history-modal').style.display = 'block';
}


function displayDeviceHistory(history) {
    const historyContainer = document.getElementById('device-history');
    historyContainer.innerHTML = '';

    if (history.length > 0) {
        let lastOfflineTime = null; // To store the last "Offline" timestamp

        for (let i = 0; i < history.length; i++) {
            const entry = history[i];
            const date = new Date(entry.timestamp);
            const formattedDate = date.toDateString(); // Example: "Wed Mar 19 2025"
            const day = date.toLocaleDateString(undefined, { weekday: 'long' }); // Example: "Wednesday"
            const time = date.toLocaleTimeString(undefined, { hour: '2-digit', minute: '2-digit', second: '2-digit' }); // Example: "12:53:16 AM"
            
            let downtimeText = '';

            // Check if the last entry was "Offline" and the current entry is "Online"
            if (lastOfflineTime && entry.status === "Online") {
                const downtimeSeconds = Math.floor((date - lastOfflineTime) / 1000); // Calculate downtime duration
                downtimeText = `<span style="color: red;"> (Downtime: ${formatDuration(downtimeSeconds)})</span>`;
                lastOfflineTime = null; // Reset after calculating downtime
            }

            // Store "Offline" timestamp to compare with the next "Online"
            if (entry.status === "Offline") {
                lastOfflineTime = date;
            }

            // Create entry div
            const entryDiv = document.createElement('div');
            entryDiv.innerHTML = `<p><strong>${day}, ${formattedDate}, ${time}</strong> - ${entry.status} ${downtimeText}</p>`;

            historyContainer.appendChild(entryDiv);
        }
    } else {
        historyContainer.innerHTML = '<p>No history available</p>';
    }
}


function closeHistoryModal() {
    document.getElementById('device-history-modal').style.display = 'none';
}


function filterData() {
    const selectedType = document.getElementById('device-type').value.toUpperCase();
    const selectedRemark = document.getElementById('remark-filter').value;

    const table = document.getElementById('device-table');
    const rows = table.getElementsByTagName('tbody')[0].getElementsByTagName('tr');

    for (let row of rows) {
        const type = row.cells[2].textContent.toUpperCase();
        const remark = row.cells[7].textContent.trim();

        const matchesType = selectedType === "ALL" || type === selectedType;
        const matchesRemark = selectedRemark === "ALL" || remark.includes(selectedRemark);

        row.style.display = matchesType && matchesRemark ? "" : "none";
    }
}


document.addEventListener("DOMContentLoaded", function () {
    document.getElementById('region').addEventListener('change', fetchDeviceData);
    fetchDeviceData(); // Initial load
});
