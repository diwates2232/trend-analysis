const regionDevices = await excelService.loadExcelData(region); // Ensure this is correctly fetching data

if (!regionDevices || !Array.isArray(regionDevices)) {
    console.error("Error: regionDevices is not loaded correctly");
    return res.status(500).json({ message: "Failed to load region devices" });
}

const downtimeUptimeData = regionDevices.map(device => {
    return {
        id: device.id,
        status: device.status
    };
});

res.json({ message: `Data for ${region}`, data: downtimeUptimeData });





const { loadExcelData, allData } = require('./excelService');




app.get('/api/region/devices/downtime-uptime/:region', (req, res) => {
    const region = req.params.region.toLowerCase();
    console.log(`Fetching downtime-uptime data for region: ${region}`);

    // Load Excel data before filtering
    loadExcelData();

    let regionDevices = [
        ...allData.cameras.filter(device => device.location?.toLowerCase() === region),
        ...allData.archivers.filter(device => device.location?.toLowerCase() === region),
        ...allData.controllers.filter(device => device.location?.toLowerCase() === region),
        ...allData.servers.filter(device => device.location?.toLowerCase() === region),
    ];

    if (regionDevices.length === 0) {
        return res.status(404).json({ message: `No devices found for region: ${region}`, data: [] });
    }

    // Collect uptime/downtime stats
    const downtimeUptimeData = regionDevices.map(device => {
        const ip = device.ip_address;
        return {
            ip,
            status: device.status || "Unknown",
            daily: uptimeDowntimeStats[ip]?.daily || {},
            weekly: uptimeDowntimeStats[ip]?.weekly || {},
            monthly: uptimeDowntimeStats[ip]?.monthly || {}
        };
    });

    res.status(200).json({ message: `Downtime-Uptime data for ${region}`, data: downtimeUptimeData });
});








app.get('/api/region/devices/downtime-uptime/:region', (req, res) => {
    const region = req.params.region.toLowerCase();
    console.log(`Fetching downtime-uptime data for region: ${region}`);

    let regionDevices = [];

    // Load Excel data
    loadExcelData();

    // Filtering devices based on the region
    regionDevices = [
        ...allData.cameras.filter(device => device.location?.toLowerCase() === region),
        ...allData.archivers.filter(device => device.location?.toLowerCase() === region),
        ...allData.controllers.filter(device => device.location?.toLowerCase() === region),
        ...allData.servers.filter(device => device.location?.toLowerCase() === region),
    ];

    if (regionDevices.length === 0) {
        return res.status(404).json({ message: `No devices found for region: ${region}`, data: [] });
    }

    // Collect uptime/downtime stats for these devices
    const downtimeUptimeData = regionDevices.map(device => {
        const ip = device.ip_address;
        return {
            ip,
            status: device.status || "Unknown",
            daily: uptimeDowntimeStats[ip]?.daily || {},
            weekly: uptimeDowntimeStats[ip]?.weekly || {},
            monthly: uptimeDowntimeStats[ip]?.monthly || {}
        };
    });

    res.status(200).json({ message: `Downtime-Uptime data for ${region}`, data: downtimeUptimeData });
});





const xlsx = require("xlsx");
const path = require("path");
const ping = require("ping");

// Paths for Excel files
const archiverPath = path.join(__dirname, "../data/ArchiverData.xlsx");
const controllerPath = path.join(__dirname, "../data/ControllerData.xlsx");
const cameraPath = path.join(__dirname, "../data/CameraData.xlsx");
const serverPath = path.join(__dirname, "../data/ServerData.xlsx");

// Cache to store preloaded data
let allData = {};

// Function to normalize column headers
const normalizeHeaders = (data) => {
    return data.map((row) => {
        const normalizedRow = {};
        for (const key in row) {
            const normalizedKey = key.trim().toLowerCase().replace(/\s+/g, '_');
            normalizedRow[normalizedKey] = row[key];
        }
        return normalizedRow;
    });
};

// Function to read and parse Excel data
const loadExcelData = () => {
    try {
        allData = {
            archivers: normalizeHeaders(xlsx.utils.sheet_to_json(xlsx.readFile(archiverPath).Sheets["Sheet1"])),
            controllers: normalizeHeaders(xlsx.utils.sheet_to_json(xlsx.readFile(controllerPath).Sheets["Sheet1"])),
            cameras: normalizeHeaders(xlsx.utils.sheet_to_json(xlsx.readFile(cameraPath).Sheets["Sheet1"])),
            servers: normalizeHeaders(xlsx.utils.sheet_to_json(xlsx.readFile(serverPath).Sheets["Sheet1"])),
        };
        console.log("âœ… Excel Data Loaded Successfully.");
    } catch (error) {
        console.error("âŒ Error loading Excel files:", error);
    }
};

// Function to ping devices and update status
const pingDevices = async (devices) => {
    const pingPromises = devices.map(async (device) => {
        if (device.ip_address) {
            try {
                const result = await ping.promise.probe(device.ip_address, { timeout: 2 });
                device.status = result.alive ? "Online" : "Offline";
            } catch (error) {
                console.error(`âŒ Error pinging ${device.ip_address}:`, error);
                device.status = "Unknown";
            }
        }
    });
    await Promise.all(pingPromises);
};

// Fetch all devices
const fetchAllDevices = async () => {
    await pingDevices([...allData.cameras, ...allData.archivers, ...allData.controllers, ...allData.servers]);
    return allData;
};

// Fetch all IPs
const fetchAllIpAddress = () => {
    const mergedDevices = [...allData.cameras, ...allData.archivers, ...allData.controllers, ...allData.servers];
    return mergedDevices.map(device => device.ip_address).filter(ip => ip);
};

// Fetch global summary & details
const fetchGlobalData = async () => {
    await pingDevices([...allData.cameras, ...allData.archivers, ...allData.controllers, ...allData.servers]);
    return { summary: calculateSummary(allData), details: allData };
};

// Fetch region-specific data
const fetchRegionData = async (regionName) => {
    console.log(`Fetching data for region: ${regionName}`);
    const lowerRegion = regionName.toLowerCase();

    const devices = {
        cameras: allData.cameras.filter(row => row.location?.toLowerCase() === lowerRegion),
        archivers: allData.archivers.filter(row => row.location?.toLowerCase() === lowerRegion),
        controllers: allData.controllers.filter(row => row.location?.toLowerCase() === lowerRegion),
        servers: allData.servers.filter(row => row.location?.toLowerCase() === lowerRegion),
    };

    await pingDevices([...devices.cameras, ...devices.archivers, ...devices.controllers, ...devices.servers]);

    return { summary: calculateSummary(devices), details: devices };
};

// Calculate device summary
const calculateSummary = (devices) => {
    let summary = { totalDevices: 0, totalOnline: 0, totalOffline: 0 };

    for (const key in devices) {
        const total = devices[key].length;
        const online = devices[key].filter(device => device.status === "Online").length;
        const offline = total - online;

        summary[key] = { total, online, offline };
        summary.totalDevices += total;
        summary.totalOnline += online;
        summary.totalOffline += offline;
    }

    return summary;
};

// Load Excel data on startup
loadExcelData();

module.exports = { fetchAllDevices, fetchGlobalData, fetchRegionData, fetchAllIpAddress };








const FILE_PATHS = {
    cameras: path.join(__dirname, "src", "data", "CameraData.xlsx"),
    archivers: path.join(__dirname, "src", "data", "ArchiverData.xlsx"),
    controllers: path.join(__dirname, "src", "data", "ControllerData.xlsx"),
    servers: path.join(__dirname, "src", "data", "ServerData.xlsx")
};






const express = require("express");
const xlsx = require("xlsx");
const ping = require("ping");
const cors = require("cors");
const path = require("path");

const app = express();
const PORT = 5000;

// Enable CORS
app.use(cors());

// Store device data and uptime/downtime statistics
let allData = { cameras: [], archivers: [], controllers: [], servers: [] };
let uptimeDowntimeStats = {};

// File paths for Excel data
const FILE_PATHS = {
    cameras: path.join(__dirname, "data", "CameraData.xlsx"),
    archivers: path.join(__dirname, "data", "ArchiverData.xlsx"),
    controllers: path.join(__dirname, "data", "ControllerData.xlsx"),
    servers: path.join(__dirname, "data", "ServerData.xlsx")
};

// Function to read data from Excel files
const readExcelData = (filePath) => {
    try {
        const workbook = xlsx.readFile(filePath);
        const sheetName = workbook.SheetNames[0];
        return xlsx.utils.sheet_to_json(workbook.Sheets[sheetName]);
    } catch (error) {
        console.error(`âŒ Error reading file: ${filePath}`, error);
        return [];
    }
};

// Load all devices into `allData`
async function fetchAllDevices() {
    console.log("ðŸ”„ Loading device data...");
    allData = {
        cameras: readExcelData(FILE_PATHS.cameras),
        archivers: readExcelData(FILE_PATHS.archivers),
        controllers: readExcelData(FILE_PATHS.controllers),
        servers: readExcelData(FILE_PATHS.servers)
    };
    console.log("âœ… Device data loaded successfully!");
    return allData;
}

// Function to check device status (ping)
async function checkDeviceStatus(ip) {
    try {
        const result = await ping.promise.probe(ip, { timeout: 2 });
        return result.alive;
    } catch (error) {
        console.error(`âŒ Error pinging ${ip}:`, error);
        return false;
    }
}

// Function to update uptime/downtime statistics
async function updateUptimeDowntimeStats() {
    console.log("ðŸ”„ Checking device status...");

    const allDevices = [
        ...allData.cameras,
        ...allData.archivers,
        ...allData.controllers,
        ...allData.servers
    ];

    for (const device of allDevices) {
        const ip = device.ip_address;
        const isOnline = await checkDeviceStatus(ip);
        const now = new Date();

        if (!uptimeDowntimeStats[ip]) {
            uptimeDowntimeStats[ip] = { online: isOnline, lastChange: now, downtimeRecords: [] };
        }

        const stats = uptimeDowntimeStats[ip];

        if (isOnline !== stats.online) {
            const downtimeDuration = (now - stats.lastChange) / (1000 * 60); // in minutes
            if (!isOnline && downtimeDuration > 5) {
                stats.downtimeRecords.push({ start: stats.lastChange, end: now, duration: downtimeDuration });
            }
            stats.online = isOnline;
            stats.lastChange = now;
        }
    }

    console.log("âœ… Device status updated!");
}

// Function to start periodic device monitoring
function startMonitoring() {
    setInterval(updateUptimeDowntimeStats, 60000);
}

// ================== API ENDPOINTS ==================

// âœ… API: Fetch all devices
app.get("/api/devices", (req, res) => {
    res.status(200).json(allData);
});

// âœ… API: Fetch details for a specific region
app.get("/api/regions/details/:region", (req, res) => {
    const region = req.params.region.toLowerCase();
    console.log(`Fetching details for region: ${region}`);

    if (!allData || !allData.cameras || !allData.archivers || !allData.controllers || !allData.servers) {
        return res.status(500).json({ error: "Device data not properly initialized." });
    }

    const regionDetails = {
        cameras: allData.cameras.filter(device => device.location?.toLowerCase() === region),
        archivers: allData.archivers.filter(device => device.location?.toLowerCase() === region),
        controllers: allData.controllers.filter(device => device.location?.toLowerCase() === region),
        servers: allData.servers.filter(device => device.location?.toLowerCase() === region)
    };

    res.status(200).json(regionDetails);
});

// âœ… API: Get uptime/downtime data for a region
app.get('/api/region/devices/downtime-uptime/:region', (req, res) => {
    const region = req.params.region.toLowerCase();
    console.log(`Fetching downtime-uptime data for region: ${region}`);

    if (!allData || !allData.cameras || !allData.archivers || !allData.controllers || !allData.servers) {
        return res.status(500).json({ error: "Device data not properly initialized." });
    }

    const regionDevices = [
        ...allData.cameras,
        ...allData.archivers,
        ...allData.controllers,
        ...allData.servers
    ].filter(device => device.location?.toLowerCase() === region);

    if (regionDevices.length === 0) {
        return res.status(404).json({ error: "No devices found for this region." });
    }

    const regionData = {};
    for (const device of regionDevices) {
        const ip = device.ip_address;
        if (uptimeDowntimeStats[ip]) {
            regionData[ip] = uptimeDowntimeStats[ip];
        } else {
            regionData[ip] = { message: "No downtime records available for this device." };
        }
    }

    res.status(200).json({ region, uptimeDowntimeData: regionData });
});

// âœ… API: Fetch global uptime/downtime data
app.get('/api/devices/global-uptime-downtime', (req, res) => {
    console.log("Fetching global uptime-downtime summary...");

    if (!uptimeDowntimeStats || Object.keys(uptimeDowntimeStats).length === 0) {
        return res.status(404).json({ error: "No uptime/downtime records available." });
    }

    res.status(200).json({ uptimeDowntimeStats });
});

// âœ… API: Fetch individual device status
app.get('/api/device/status/:ip', (req, res) => {
    const ip = req.params.ip;
    console.log(`Fetching status for device with IP: ${ip}`);

    if (!uptimeDowntimeStats[ip]) {
        return res.status(404).json({ error: "No records found for this IP." });
    }

    res.status(200).json(uptimeDowntimeStats[ip]);
});

// âœ… API: Trigger manual status check
app.get('/api/devices/check-status', async (req, res) => {
    console.log("Manually checking device status...");
    await updateUptimeDowntimeStats();
    res.status(200).json({ message: "Device status updated!" });
});

// ================== SERVER STARTUP ==================

// Load data and start the server
fetchAllDevices().then(() => {
    app.listen(PORT, () => {
        console.log(`ðŸš€ Server running on http://localhost:${PORT}`);
        startMonitoring();
    });
});






const express = require("express");
const cors = require("cors");
const { fetchAllDevices, fetchGlobalData, fetchRegionData, fetchAllIpAddress } = require("./services/excelservice");

const app = express();
const PORT = 5000;

// Middleware
app.use(cors());
app.use(express.json());

// API: Get all devices
app.get("/api/devices", async (req, res) => {
    try {
        const data = await fetchAllDevices();
        res.status(200).json(data);
    } catch (error) {
        console.error("âŒ Error fetching devices:", error);
        res.status(500).json({ error: "Internal server error" });
    }
});

// API: Get global summary & details
app.get("/api/regions/details/global", async (req, res) => {
    try {
        const data = await fetchGlobalData();
        res.status(200).json(data);
    } catch (error) {
        console.error("âŒ Error fetching global data:", error);
        res.status(500).json({ error: "Internal server error" });
    }
});

// API: Get region summary & details
app.get("/api/regions/details/:region", async (req, res) => {
    const region = req.params.region;
    try {
        const data = await fetchRegionData(region);
        res.status(200).json(data);
    } catch (error) {
        console.error(`âŒ Error fetching data for region ${region}:`, error);
        res.status(500).json({ error: "Internal server error" });
    }
});

// API: Get all IP addresses
app.get("/api/devices/ips", (req, res) => {
    try {
        const ipAddresses = fetchAllIpAddress();
        res.status(200).json({ ipAddresses });
    } catch (error) {
        console.error("âŒ Error fetching IP addresses:", error);
        res.status(500).json({ error: "Internal server error" });
    }
});

// Start the server
app.listen(PORT, () => {
    console.log(`ðŸš€ Server running on http://localhost:${PORT}`);
});
