excelservice.js


const xlsx = require("xlsx");
const path = require("path");
const ping = require("ping");

// Paths for Excel files
const archiverPath = path.join(__dirname, "../data/ArchiverData.xlsx");
const controllerPath = path.join(__dirname, "../data/ControllerData.xlsx");
const cameraPath = path.join(__dirname, "../data/CameraData.xlsx");
const serverPath = path.join(__dirname, "../data/ServerData.xlsx");

// Cache to store preloaded data
let allData = {};

// Function to normalize column headers
const normalizeHeaders = (data) => {
    return data.map((row) => {
        const normalizedRow = {};
        for (const key in row) {
            const normalizedKey = key.trim().toLowerCase().replace(/\s+/g, '_');
            normalizedRow[normalizedKey] = row[key];
        }
        return normalizedRow;
    });
};

const loadExcelData = () => {
    if (Object.keys(allData).length === 0) { // Load only if not already loaded
        const archiverWorkbook = xlsx.readFile(archiverPath);
        const controllerWorkbook = xlsx.readFile(controllerPath);
        const cameraWorkbook = xlsx.readFile(cameraPath);
        const serverWorkbook = xlsx.readFile(serverPath);

        allData = {
            archivers: normalizeHeaders(xlsx.utils.sheet_to_json(archiverWorkbook.Sheets[archiverWorkbook.SheetNames[0]])),
            controllers: normalizeHeaders(xlsx.utils.sheet_to_json(controllerWorkbook.Sheets[controllerWorkbook.SheetNames[0]])),
            cameras: normalizeHeaders(xlsx.utils.sheet_to_json(cameraWorkbook.Sheets[cameraWorkbook.SheetNames[0]])),
            servers: normalizeHeaders(xlsx.utils.sheet_to_json(serverWorkbook.Sheets[serverWorkbook.SheetNames[0]])),
        };
        console.log("✅ Excel Data Loaded.");
    }
};

// Function to fetch all device data
const fetchAllDevices = () => {
    return allData;
};

// Function to fetch all IP addresses
const fetchAllIpAddress = () => {
    const devices = {
        cameras: allData.cameras || [],
        archivers: allData.archivers || [],
        controllers: allData.controllers || [],
        servers: allData.servers || [],
    };

    const merged = [...devices.cameras, ...devices.archivers, ...devices.controllers, ...devices.servers];
    const addresses = merged.map(device => device.ip_address).filter(ip => ip); // Remove undefined IPs
    return addresses;
};

// Function to compute global summary and details
const fetchGlobalData = async () => {
    const devices = {
        cameras: allData.cameras,
        archivers: allData.archivers,
        controllers: allData.controllers,
        servers: allData.servers,
    };

    await pingDevices([...devices.cameras, ...devices.archivers, ...devices.controllers, ...devices.servers]);

    const summary = calculateSummary(devices);
    return { summary, details: devices };
};

// Function to compute region summary and details
const fetchRegionData = async (regionName) => {
    console.log(`Fetching data for region: ${regionName}`);
    
    const filteredCameras = allData.cameras.filter(row => row.location?.toLowerCase() === regionName.toLowerCase());
    const filteredArchivers = allData.archivers.filter(row => row.location?.toLowerCase() === regionName.toLowerCase());
    const filteredControllers = allData.controllers.filter(row => row.location?.toLowerCase() === regionName.toLowerCase());
    const filteredServers = allData.servers.filter(row => row.location?.toLowerCase() === regionName.toLowerCase());

    const devices = { cameras: filteredCameras, archivers: filteredArchivers, controllers: filteredControllers, servers: filteredServers };

    console.log(`Filtered Devices:`, devices);

    await pingDevices([...filteredCameras, ...filteredArchivers, ...filteredControllers, ...filteredServers]);

    const summary = calculateSummary(devices);
    return { summary, details: devices };
};

// Function to compute summary
const calculateSummary = (devices) => {
    const summary = {};

    for (const [key, deviceList] of Object.entries(devices)) {
        const total = deviceList.length;
        const online = deviceList.filter(device => device.status === "Online").length;
        const offline = total - online;

        summary[key] = { total, online, offline };
    }

    return {
        totalDevices: Object.values(summary).reduce((sum, { total }) => sum + total, 0),
        totalOnlineDevices: Object.values(summary).reduce((sum, { online }) => sum + online, 0),
        totalOfflineDevices: Object.values(summary).reduce((sum, { offline }) => sum + offline, 0),
        ...summary,
    };
};

// Function to fetch uptime data
const fetchDeviceUptimeData = () => {
    return deviceDowntimeData;
};

// Preload data
loadExcelData();

module.exports = { fetchAllDevices, fetchGlobalData, fetchRegionData, fetchAllIpAddress, fetchDeviceUptimeData };











app.js

const express = require("express");
const xlsx = require("xlsx");
const ping = require("ping");
const cors = require("cors");

const app = express();
const PORT = 5000;

// Enable CORS
app.use(cors());

// Global storage for device data
let allData = {
  cameras: [],
  archivers: [],
  controllers: [],
  servers: []
};

// Store uptime and downtime stats
let uptimeDowntimeStats = {};

// File paths for device data
const path = require("path");

// Correct file paths
const FILE_PATHS = {
  cameras: path.join(__dirname, "data", "CameraData.xlsx"),
  archivers: path.join(__dirname, "data", "ArchiverData.xlsx"),
  controllers: path.join(__dirname, "data", "ControllerData.xlsx"),
  servers: path.join(__dirname, "data", "ServerData.xlsx")
};

// Function to read data from Excel
const readExcelData = (filePath) => {
  try {
    const workbook = xlsx.readFile(filePath);
    const sheetName = workbook.SheetNames[0];
    return xlsx.utils.sheet_to_json(workbook.Sheets[sheetName]);
  } catch (error) {
    console.error(`❌ Error reading file: ${filePath}`, error);
    return [];
  }
};

// Load all devices into allData
async function fetchAllDevices() {
  console.log("🔄 Loading device data...");
  allData = {
    cameras: readExcelData(FILE_PATHS.cameras),
    archivers: readExcelData(FILE_PATHS.archivers),
    controllers: readExcelData(FILE_PATHS.controllers),
    servers: readExcelData(FILE_PATHS.servers)
  };
  console.log("✅ Device data loaded successfully!");
  return allData;
}

// API: Get device details by region
app.get("/api/regions/details/:region", (req, res) => {
  const region = req.params.region.toLowerCase();
  console.log(`Fetching details for region: ${region}`);

  if (!allData || !allData.cameras || !allData.archivers || !allData.controllers || !allData.servers) {
    return res.status(500).json({ error: "Device data not properly initialized." });
  }

  const regionDetails = {
    cameras: allData.cameras.filter(device => device.location?.toLowerCase() === region),
    archivers: allData.archivers.filter(device => device.location?.toLowerCase() === region),
    controllers: allData.controllers.filter(device => device.location?.toLowerCase() === region),
    servers: allData.servers.filter(device => device.location?.toLowerCase() === region)
  };

  res.status(200).json(regionDetails);
});

// API: Get downtime/uptime data for a region
app.get('/api/region/devices/downtime-uptime/:region', (req, res) => {
  const region = req.params.region.toLowerCase();
  console.log(`Fetching downtime-uptime data for region: ${region}`);

  if (!allData || !allData.cameras || !allData.archivers || !allData.controllers || !allData.servers) {
    return res.status(500).json({ error: "Device data not properly initialized." });
  }

  const regionDevices = [];

  [...allData.cameras, ...allData.archivers, ...allData.controllers, ...allData.servers].forEach(device => {
    if (device.location?.toLowerCase() === region) {
      regionDevices.push(device.ip_address);
    }
  });

  if (regionDevices.length === 0) {
    return res.status(404).json({ error: "No devices found for this region." });
  }

  const regionData = {};
  for (const ip of regionDevices) {
    if (uptimeDowntimeStats[ip]) {
      regionData[ip] = uptimeDowntimeStats[ip];
    }
  }

  res.status(200).json({ region, uptimeDowntimeData: regionData });
});

// Function to check device status (ping)
async function checkDeviceStatus(ip) {
  try {
    const result = await ping.promise.probe(ip, { timeout: 2 });
    return result.alive;
  } catch (error) {
    console.error(`❌ Error pinging ${ip}:`, error);
    return false;
  }
}

// Function to update uptime/downtime statistics
async function updateUptimeDowntimeStats() {
  console.log("🔄 Checking device status...");

  const allDevices = [
    ...allData.cameras,
    ...allData.archivers,
    ...allData.controllers,
    ...allData.servers
  ];

  for (const device of allDevices) {
    const ip = device.ip_address;
    const isOnline = await checkDeviceStatus(ip);
    const now = new Date();

    if (!uptimeDowntimeStats[ip]) {
      uptimeDowntimeStats[ip] = { online: isOnline, lastChange: now, downtimeRecords: [] };
    }

    const stats = uptimeDowntimeStats[ip];

    if (isOnline !== stats.online) {
      const downtimeDuration = (now - stats.lastChange) / (1000 * 60); // in minutes
      if (!isOnline && downtimeDuration > 5) {
        stats.downtimeRecords.push({ start: stats.lastChange, end: now, duration: downtimeDuration });
      }
      stats.online = isOnline;
      stats.lastChange = now;
    }
  }

  console.log("✅ Device status updated!");
}

// Function to start periodic device monitoring
function startMonitoring() {
  setInterval(updateUptimeDowntimeStats, 60000);
}

// Load data and start the server
fetchAllDevices().then(() => {
  app.listen(PORT, () => {
    console.log(`🚀 Server running on http://localhost:${PORT}`);
    startMonitoring();
  });
});
