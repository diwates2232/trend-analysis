
// function to fetch trend
const fetchRegionTrendData = async (region) => {
    console.log("Fetching trend data for region:", region);

    if (!allData || !allData.cameras) {
        console.error("Error: allData is undefined or missing cameras property");
        return null; // Prevent further errors
    }

    const devices = {
        cameras: allData.cameras
            .filter(device => device.location?.toLowerCase() === region.toLowerCase())
            .map(device => ({
                ...device,
                history: Array.isArray(device.history) ? device.history : [] // Ensure history is an array
            })),
        archivers: allData.archivers
            ? allData.archivers.filter(device => device.location?.toLowerCase() === region.toLowerCase())
            : [],
        controllers: allData.controllers
            ? allData.controllers.filter(device => device.location?.toLowerCase() === region.toLowerCase())
            : [],
        servers: allData.servers
            ? allData.servers.filter(device => device.location?.toLowerCase() === region.toLowerCase())
            : []
    };

    console.log("Devices with History:", JSON.stringify(devices, null, 2));

    if (!devices.cameras.length && !devices.archivers.length && !devices.controllers.length && !devices.servers.length) {
        console.log(`No devices found for region: ${region}`);
        return null;
    }

    // For each device, compute trend and status
    const deviceTrends = calculateDeviceTrends(devices);

    // Create the response object in the required format
    const response = {
        region: region,
        trends: deviceTrends,
        devices: {
            cameras: devices.cameras.map(device => ({
                device_name: device.device_name,
                status: device.status,
                ip_address: device.ip_address,
                location: device.location
            })),
            archivers: devices.archivers.map(device => ({
                device_name: device.device_name,
                status: device.status,
                ip_address: device.ip_address,
                location: device.location
            })),
            controllers: devices.controllers.map(device => ({
                device_name: device.device_name,
                status: device.status,
                ip_address: device.ip_address,
                location: device.location
            })),
            servers: devices.servers.map(device => ({
                device_name: device.device_name,
                status: device.status,
                ip_address: device.ip_address,
                location: device.location
            }))
        }
    };

    return response;
};

// Modify calculateTrend to include device-specific details
const calculateDeviceTrends = (devices) => {
    const trends = {
        daily: [],
        weekly: [],
        monthly: [],
    };

    // Process each device type
    // Helper function to calculate detailed trends
const calculateTrend = (devices, period) => {
    return devices.map(device => {
        const { uptime, downtime, downtimeDuration } = computeDeviceStats(device.history);
        return {
            deviceName: device.device_name || "Unknown",
            ipAddress: device.ip_address,
            uptime,
            downtime,
            downtimeDuration
        };
    });
};


// You would likely want to extend this to weekly and monthly calculations based on the data available.

    trends.weekly = trends.daily; 
    trends.monthly = trends.daily; 

    return trends;
};

// Compute device uptime and downtime
const computeDeviceStats = (history) => {
    if (!Array.isArray(history) || history.length === 0) {
        console.log("No history data found for device");
        return { uptime: 0, downtime: 0, downtimeDuration: 0 };
    }

    let uptime = 0, downtime = 0, downtimeDuration = 0;
    let lastStatus = null;
    let lastTimestamp = null;

    history.forEach((log, index) => {
        let currentTime = new Date(log.timestamp).getTime();

        // Debugging: Log the log details
        console.log(`Log ${index}: Status: ${log.status}, Timestamp: ${log.timestamp}`);

        // Skip the first entry since there's no previous log to compare
        if (index > 0 && lastTimestamp) {
            let timeDiff = (currentTime - lastTimestamp) / 60000; // Convert ms to minutes

            // Debugging: Log time difference
            console.log(`Time Difference (in minutes) between logs: ${timeDiff}`);

            if (lastStatus === "online") {
                uptime += timeDiff; // Add uptime duration
            } else if (lastStatus === "offline") {
                downtime += timeDiff; // Add downtime duration
                downtimeDuration++;
            }
        }

        lastStatus = log.status;
        lastTimestamp = currentTime;
    });

    // Debugging: Log final uptime and downtime
    console.log(`Final Uptime: ${uptime} minutes, Downtime: ${downtime} minutes, Downtime Duration: ${downtimeDuration}`);

    return { uptime: Math.round(uptime), downtime: Math.round(downtime), downtimeDuration };
};

