const baseUrl = "http://localhost:80/api/regions";
let refreshInterval = 300000; // 5 minutes
let pingInterval = 30000; // 30 seconds
let countdownTime = refreshInterval / 1000; // Convert to seconds
let currentRegion = "global";
let deviceDetailsCache = {}; // Store previous details to prevent redundant updates
let latestDetails = null; // Cache the latest fetched details

document.addEventListener("DOMContentLoaded", () => {
    fetchData("global"); // Load initial data
    startAutoRefresh("global");

    document.querySelectorAll(".region-button").forEach((button) => {
        button.addEventListener("click", () => {
            const region = button.getAttribute("data-region");
            document.getElementById("region-title").textContent = `${region.toUpperCase()} Summary`;
            switchRegion(region);
        });
    });

    document.getElementById("close-modal").addEventListener("click", () => {
        document.getElementById("modal").style.display = "none";
    });
});

function switchRegion(region) {
    clearExistingIntervals(); // Avoid interval duplication
    currentRegion = region;
    deviceDetailsCache = {};
    fetchData(region);
    startAutoRefresh(region);
}

// **Auto-refresh mechanism**
function startAutoRefresh(regionName) {
    fetchData(regionName); // Fetch initial data

    clearExistingIntervals();

    // Start countdown timer
    window.countdownTimer = setInterval(() => {
        document.getElementById("countdown").innerText = `Refreshing in ${countdownTime} seconds`;
        countdownTime--;
        if (countdownTime < 0) countdownTime = refreshInterval / 1000;
    }, 1000);

    // Refresh summary & details every 5 minutes
    window.refreshTimer = setInterval(() => {
        fetchData(regionName);
        countdownTime = refreshInterval / 1000;
    }, refreshInterval);

    // Ping devices every 30 seconds using history API
    window.pingTimer = setInterval(() => {
        pingAllDevices(regionName);
    }, pingInterval);
}

function clearExistingIntervals() {
    clearInterval(window.countdownTimer);
    clearInterval(window.refreshTimer);
    clearInterval(window.pingTimer);
}

// **Fetch summary and details together**
function fetchData(regionName) {
    Promise.all([
        fetch(`${baseUrl}/summary/${regionName}`).then(res => res.json()),
        fetch(`${baseUrl}/details/${regionName}`).then(res => res.json())
    ])
    .then(([summary, details]) => {
        console.log("Summary Data:", summary);
        console.log("Details Data:", details);

        updateSummary(summary);
        
        if (JSON.stringify(details) !== JSON.stringify(deviceDetailsCache)) {
            updateDetails(details);
            deviceDetailsCache = details; // Update cache
        }
        // Cache details for pinging
        latestDetails = details;
    })
    .catch((error) => console.error("Error fetching data:", error));
}

/*
   Updated pingAllDevices:
   Instead of calling a non-existent ping endpoint, we now use the history API to fetch 
   device history and update each deviceâ€™s status by updating the separate status dot and text.
*/
function pingAllDevices(regionName) {
    let details = latestDetails;
    if (!details || !details.details) return;

    fetch("http://localhost/api/devices/history")
        .then(response => response.json())
        .then(historyData => {
            let statusChanged = false;

            for (const [key, devices] of Object.entries(details.details)) {
                if (!Array.isArray(devices) || devices.length === 0) continue;

                devices.forEach((device) => {
                    const ip = device.ip_address || "N/A";
                    const card = document.querySelector(`[data-ip="${ip}"]`);
                    if (!card) return;

                    // Determine new status from history API if available.
                    const historyArray = historyData[ip];
                    let newStatus = (device.status || "offline").toLowerCase();
                    if (Array.isArray(historyArray) && historyArray.length > 0) {
                        const latestEntry = historyArray[historyArray.length - 1];
                        newStatus = (latestEntry.status || "offline").toLowerCase();
                    }
                    const currentStatus = card.dataset.status;

                    // Update UI: update the dot and the text.
                    const statusDot = card.querySelector(".status-dot");
                    const statusText = card.querySelector(".status-text");
                    if (statusDot) {
                        statusDot.style.backgroundColor = (newStatus === "online") ? "green" : "red";
                    } else {
                        console.warn(`Status dot element not found for IP: ${ip}`);
                    }
                    if (statusText) {
                        statusText.textContent = newStatus.charAt(0).toUpperCase() + newStatus.slice(1);
                    } else {
                        console.warn(`Status text element not found for IP: ${ip}`);
                    }

                    if (newStatus !== currentStatus) {
                        statusChanged = true;
                        card.dataset.status = newStatus;
                    }
                });
            }

            setTimeout(() => {
                if (statusChanged) {
                    fetchData(regionName);
                }
            }, 5000);
        })
        .catch(error => {
            console.error("Error fetching device history:", error);
        });
}

function updateSummary(data) {
    document.getElementById("total-devices").textContent = data.summary?.totalDevices || "0";
    document.getElementById("online-devices").textContent = data.summary?.totalOnlineDevices || "0";
    document.getElementById("offline-devices").textContent = data.summary?.totalOfflineDevices || "0";

    document.getElementById("camera-total").textContent = data.summary?.cameras?.total || "0";
    document.getElementById("camera-online").textContent = data.summary?.cameras?.online || "0";
    document.getElementById("camera-offline").textContent = data.summary?.cameras?.offline || "0";

    document.getElementById("archiver-total").textContent = data.summary?.archivers?.total || "0";
    document.getElementById("archiver-online").textContent = data.summary?.archivers?.online || "0";
    document.getElementById("archiver-offline").textContent = data.summary?.archivers?.offline || "0";

    document.getElementById("controller-total").textContent = data.summary?.controllers?.total || "0";
    document.getElementById("controller-online").textContent = data.summary?.controllers?.online || "0";
    document.getElementById("controller-offline").textContent = data.summary?.controllers?.offline || "0";

    document.getElementById("server-total").textContent = data.summary?.servers?.total || "0";
    document.getElementById("server-online").textContent = data.summary?.servers?.online || "0";
    document.getElementById("server-offline").textContent = data.summary?.servers?.offline || "0";
}

/*
   Updated updateDetails:
   Each device card is built with separate elements for the status dot and status text.
   This ensures that later updates from pingAllDevices can reliably find and update them.
*/
function updateDetails(data) {
    const detailsContainer = document.getElementById("device-details");
    const deviceFilter = document.getElementById("device-filter");
    const onlineFilterButton = document.getElementById("filter-online");
    const offlineFilterButton = document.getElementById("filter-offline");
    const allFilterButton = document.getElementById("filter-all");
    const cityFilter = document.getElementById("city-filter");

    detailsContainer.innerHTML = "";
    cityFilter.innerHTML = '<option value="all">All Cities</option>';

    let combinedDevices = [];
    let citySet = new Set();

    // Fetch real-time status if available.
    fetch("http://localhost:80/api/region/devices/status")
        .then((response) => response.json())
        .then((realTimeStatus) => {
            console.log("Live Status Data:", realTimeStatus);

            for (const [key, devices] of Object.entries(data.details)) {
                if (!Array.isArray(devices) || devices.length === 0) continue;
                const deviceType = key.toLowerCase();

                devices.forEach((device) => {
                    const deviceIP = device.ip_address || "N/A";
                    let currentStatus = (realTimeStatus[deviceIP] || device.status || "offline").toLowerCase();
                    const city = device.city || "Unknown";
                    citySet.add(city);

                    // Create card element.
                    const card = document.createElement("div");
                    card.className = "device-card";
                    card.dataset.type = deviceType;
                    card.dataset.status = currentStatus;
                    card.dataset.city = city;
                    card.setAttribute("data-ip", deviceIP);

                    // Create a container for status.
                    const statusContainer = document.createElement("p");
                    statusContainer.className = "device-status";
                    statusContainer.textContent = "Status: ";

                    // Create the status text element.
                    const statusText = document.createElement("span");
                    statusText.className = "status-text";
                    statusText.textContent = currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1);

                    // Create the status dot element.
                    const statusDot = document.createElement("span");
                    statusDot.className = "status-dot";
                    statusDot.style.backgroundColor = (currentStatus === "online") ? "green" : "red";
                    statusDot.style.display = "inline-block";
                    statusDot.style.width = "10px";
                    statusDot.style.height = "10px";
                    statusDot.style.marginLeft = "5px";
                    statusDot.style.borderRadius = "50%";

                    // Append status text and dot to the container.
                    statusContainer.appendChild(statusText);
                    statusContainer.appendChild(statusDot);

                    card.innerHTML = `
                        <h3>${device.cameraname || device.controllername || device.archivername || device.servername || "Unknown Device"}</h3>
                        <p>DEVICE TYPE: ${deviceType.toUpperCase()}</p>
                        <p>IP: ${deviceIP}</p>
                        <p>LOCATION: ${device.location || "N/A"}</p>
                        <p>CITY: ${city}</p>
                    `;
                    card.appendChild(statusContainer);
                    card.innerHTML += `
                        <button class="details-button" onclick="showModal('${device.cameraname || device.controllername || device.archivername || device.servername || "Unknown Device"}', '${deviceIP}', '${device.location || "N/A"}', '${currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1)}', '${city}')">Details</button>
                    `;

                    combinedDevices.push({
                        card: card,
                        device: {
                            type: deviceType,
                            status: currentStatus,
                            city: city
                        }
                    });
                });
            }

            combinedDevices.sort((a, b) => {
                const statusA = (a.device.status === "offline") ? 0 : 1;
                const statusB = (b.device.status === "offline") ? 0 : 1;
                return statusA - statusB;
            });

            const allDevices = combinedDevices.map(item => item.card);
            const deviceObjects = combinedDevices.map(item => item.device);

            citySet.forEach((city) => {
                const option = document.createElement("option");
                option.value = city;
                option.textContent = city;
                cityFilter.appendChild(option);
            });

            deviceFilter.value = "all";
            cityFilter.value = "all";
            document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
            allFilterButton.classList.add("active");

            function filterDevices() {
                const selectedType = deviceFilter.value;
                const selectedStatus = document.querySelector(".status-filter.active")?.dataset.status || "all";
                const selectedCity = cityFilter.value;

                detailsContainer.innerHTML = "";

                const filteredDevices = allDevices.filter((device) =>
                    (selectedType === "all" || device.dataset.type === selectedType) &&
                    (selectedStatus === "all" || device.dataset.status === selectedStatus) &&
                    (selectedCity === "all" || device.dataset.city === selectedCity)
                );

                filteredDevices.forEach((deviceCard) => {
                    detailsContainer.appendChild(deviceCard);
                });

                const region = currentRegion?.toUpperCase() || "GLOBAL";
                if (selectedCity !== "all") {
                    document.getElementById("region-title").textContent = `${region}, ${selectedCity} Summary`;
                } else {
                    document.getElementById("region-title").textContent = `${region} Summary`;
                }

                const filteredSummaryDevices = deviceObjects.filter((deviceObj, index) => {
                    const correspondingCard = allDevices[index];
                    return (
                        (selectedType === "all" || correspondingCard.dataset.type === selectedType) &&
                        (selectedStatus === "all" || correspondingCard.dataset.status === selectedStatus) &&
                        (selectedCity === "all" || correspondingCard.dataset.city === selectedCity)
                    );
                });

                const summary = calculateCitySummary(filteredSummaryDevices);
                updateSummary(summary);
            }

            function calculateCitySummary(devices) {
                const summary = {
                    summary: {
                        totalDevices: devices.length,
                        totalOnlineDevices: devices.filter(d => d.status === "online").length,
                        totalOfflineDevices: devices.filter(d => d.status === "offline").length,
                        cameras: { total: 0, online: 0, offline: 0 },
                        archivers: { total: 0, online: 0, offline: 0 },
                        controllers: { total: 0, online: 0, offline: 0 },
                        servers: { total: 0, online: 0, offline: 0 },
                    }
                };

                devices.forEach((device) => {
                    if (!summary.summary[device.type]) return;
                    summary.summary[device.type].total += 1;
                    if (device.status === "online") summary.summary[device.type].online += 1;
                    else summary.summary[device.type].offline += 1;
                });

                return summary;
            }

            filterDevices();

            setTimeout(() => {
                const selectedCity = cityFilter.value;
                const selectedType = deviceFilter.value;
                const selectedStatus = document.querySelector(".status-filter.active")?.dataset.status || "all";

                const filteredSummaryDevices = deviceObjects.filter((deviceObj, index) => {
                    const correspondingCard = allDevices[index];
                    return (
                        (selectedType === "all" || correspondingCard.dataset.type === selectedType) &&
                        (selectedStatus === "all" || correspondingCard.dataset.status === selectedStatus) &&
                        (selectedCity === "all" || correspondingCard.dataset.city === selectedCity)
                    );
                });

                const summary = calculateCitySummary(filteredSummaryDevices);
                updateSummary(summary);
            }, 100);

            deviceFilter.addEventListener("change", filterDevices);
            cityFilter.addEventListener("change", filterDevices);
            allFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                allFilterButton.classList.add("active");
                filterDevices();
            });
            onlineFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                onlineFilterButton.classList.add("active");
                filterDevices();
            });
            offlineFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                offlineFilterButton.classList.add("active");
                filterDevices();
            });
        })
        .catch((error) => {
            console.error("Error fetching real-time device status:", error);
            detailsContainer.innerHTML = "<p>Failed to load device details.</p>";
        });
}

function showModal(name, ip, location, status, city) {
    document.getElementById("modal-title").textContent = `Details for ${name}`;
    document.getElementById("modal-body").innerHTML = `
        <li><strong>Name:</strong> ${name}</li>
        <li><strong>IP:</strong> ${ip}</li>
        <li><strong>Location:</strong> ${location}</li>
        <li><strong>Status:</strong> ${status}</li>
        <li><strong>City:</strong> ${city}</li>
    `;
    document.getElementById("modal").style.display = "block";
}
















const baseUrl = "http://localhost:80/api/regions";
let refreshInterval = 300000; // 5 minutes
let pingInterval = 30000; // 30 seconds
let countdownTime = refreshInterval / 1000; // Convert to seconds
let currentRegion = "global";
let deviceDetailsCache = {}; // Store previous details to prevent redundant updates
let latestDetails = null; // Cache the latest fetched details

document.addEventListener("DOMContentLoaded", () => {
    fetchData("global"); // Load initial data
    startAutoRefresh("global");

    document.querySelectorAll(".region-button").forEach((button) => {
        button.addEventListener("click", () => {
            const region = button.getAttribute("data-region");
            document.getElementById("region-title").textContent = `${region.toUpperCase()} Summary`;
            switchRegion(region);
        });
    });

    document.getElementById("close-modal").addEventListener("click", () => {
        document.getElementById("modal").style.display = "none";
    });
});

function switchRegion(region) {
    clearExistingIntervals(); // Avoid interval duplication
    currentRegion = region;
    deviceDetailsCache = {};
    fetchData(region);
    startAutoRefresh(region);
}

// **Auto-refresh mechanism**
function startAutoRefresh(regionName) {
    fetchData(regionName); // Fetch initial data

    clearExistingIntervals();

    // Start countdown timer
    window.countdownTimer = setInterval(() => {
        document.getElementById("countdown").innerText = `Refreshing in ${countdownTime} seconds`;
        countdownTime--;
        if (countdownTime < 0) countdownTime = refreshInterval / 1000;
    }, 1000);

    // Refresh summary & details every 5 minutes
    window.refreshTimer = setInterval(() => {
        fetchData(regionName);
        countdownTime = refreshInterval / 1000;
    }, refreshInterval);

    // Ping devices every 30 seconds using history API
    window.pingTimer = setInterval(() => {
        pingAllDevices(regionName);
    }, pingInterval);
}

function clearExistingIntervals() {
    clearInterval(window.countdownTimer);
    clearInterval(window.refreshTimer);
    clearInterval(window.pingTimer);
}

// **Fetch summary and details together**
function fetchData(regionName) {
    Promise.all([
        fetch(`${baseUrl}/summary/${regionName}`).then(res => res.json()),
        fetch(`${baseUrl}/details/${regionName}`).then(res => res.json())
    ])
    .then(([summary, details]) => {
        console.log("Summary Data:", summary);
        console.log("Details Data:", details);

        // Update summary from backend data
        updateSummary(summary);
        
        if (JSON.stringify(details) !== JSON.stringify(deviceDetailsCache)) {
            updateDetails(details);
            deviceDetailsCache = details; // Update cache
        }
        // Cache details for pinging
        latestDetails = details;
    })
    .catch((error) => console.error("Error fetching data:", error));
}

/* 
   Updated pingAllDevices:
   Instead of pinging with an incorrect API, this function now fetches the device history
   from the history API. For each device, it retrieves the most recent status from the history 
   and updates the UI accordingly.
*/
function pingAllDevices(regionName) {
    // Use cached latestDetails if available
    let details = latestDetails;
    if (!details || !details.details) return;

    fetch("http://localhost/api/devices/history")
        .then(response => response.json())
        .then(historyData => {
            let statusChanged = false; // Track if any status changed

            // Loop through each device type (cameras, archivers, etc.)
            for (const [key, devices] of Object.entries(details.details)) {
                if (!Array.isArray(devices) || devices.length === 0) continue;

                devices.forEach((device) => {
                    const ip = device.ip_address || "N/A";
                    const card = document.querySelector(`[data-ip="${ip}"]`);
                    if (!card) return; // Skip if the device UI is not found

                    // Use history API data: historyData keys are IP addresses with arrays of history entries.
                    const historyArray = historyData[ip];
                    let newStatus = (device.status || "offline").toLowerCase();
                    if (Array.isArray(historyArray) && historyArray.length > 0) {
                        // Use the status from the last history record.
                        const latestEntry = historyArray[historyArray.length - 1];
                        newStatus = (latestEntry.status || "offline").toLowerCase();
                    }
                    const currentStatus = card.dataset.status;

                    // Update UI instantly
                    const statusDot = card.querySelector(".status-dot");
                    const statusText = card.querySelector(".device-status");
                    if (statusDot) {
                        statusDot.style.backgroundColor = (newStatus === "online") ? "green" : "red";
                    } else {
                        console.warn(`Status dot element not found for IP: ${ip}`);
                    }
                    if (statusText) {
                        statusText.textContent = newStatus.charAt(0).toUpperCase() + newStatus.slice(1);
                    } else {
                        console.warn(`Status text element not found for IP: ${ip}`);
                    }

                    if (newStatus !== currentStatus) {
                        statusChanged = true; // A change in status was detected
                        card.dataset.status = newStatus; // Update dataset
                    }
                });
            }

            // After processing all devices, if any status changed, refresh summary
            setTimeout(() => {
                if (statusChanged) {
                    fetchData(regionName);
                }
            }, 5000); // Small delay to ensure all updates are processed
        })
        .catch(error => {
            console.error("Error fetching device history:", error);
        });
}

function updateSummary(data) {
    document.getElementById("total-devices").textContent = data.summary?.totalDevices || "0";
    document.getElementById("online-devices").textContent = data.summary?.totalOnlineDevices || "0";
    document.getElementById("offline-devices").textContent = data.summary?.totalOfflineDevices || "0";

    document.getElementById("camera-total").textContent = data.summary?.cameras?.total || "0";
    document.getElementById("camera-online").textContent = data.summary?.cameras?.online || "0";
    document.getElementById("camera-offline").textContent = data.summary?.cameras?.offline || "0";

    document.getElementById("archiver-total").textContent = data.summary?.archivers?.total || "0";
    document.getElementById("archiver-online").textContent = data.summary?.archivers?.online || "0";
    document.getElementById("archiver-offline").textContent = data.summary?.archivers?.offline || "0";

    document.getElementById("controller-total").textContent = data.summary?.controllers?.total || "0";
    document.getElementById("controller-online").textContent = data.summary?.controllers?.online || "0";
    document.getElementById("controller-offline").textContent = data.summary?.controllers?.offline || "0";

    document.getElementById("server-total").textContent = data.summary?.servers?.total || "0";
    document.getElementById("server-online").textContent = data.summary?.servers?.online || "0";
    document.getElementById("server-offline").textContent = data.summary?.servers?.offline || "0";
}

function updateDetails(data) {
    const detailsContainer = document.getElementById("device-details");
    const deviceFilter = document.getElementById("device-filter");
    const onlineFilterButton = document.getElementById("filter-online");
    const offlineFilterButton = document.getElementById("filter-offline");
    const allFilterButton = document.getElementById("filter-all");
    const cityFilter = document.getElementById("city-filter");

    detailsContainer.innerHTML = ""; // Clear previous data
    cityFilter.innerHTML = '<option value="all">All Cities</option>';

    let combinedDevices = []; // Array to hold both the card and its device info for summary
    let citySet = new Set();

    // Fetch real-time status from the backend (if available)
    fetch("http://localhost:80/api/region/devices/status")
        .then((response) => response.json())
        .then((realTimeStatus) => {
            console.log("Live Status Data:", realTimeStatus);

            for (const [key, devices] of Object.entries(data.details)) {
                if (!Array.isArray(devices) || devices.length === 0) continue;

                const deviceType = key.toLowerCase();

                devices.forEach((device) => {
                    const deviceIP = device.ip_address || "N/A";
                    // Use real-time status if available; otherwise use device.status
                    let currentStatus = (realTimeStatus[deviceIP] || device.status || "offline").toLowerCase();
                    const city = device.city || "Unknown";

                    citySet.add(city);

                    const card = document.createElement("div");
                    card.className = "device-card";
                    card.dataset.type = deviceType;
                    card.dataset.status = currentStatus;
                    card.dataset.city = city;
                    card.setAttribute("data-ip", deviceIP);

                    const statusDot = document.createElement("span");
                    statusDot.className = "status-dot";
                    statusDot.style.backgroundColor = (currentStatus === "online") ? "green" : "red";

                    card.innerHTML = `
                        <h3>${device.cameraname || device.controllername || device.archivername || device.servername || "Unknown Device"}</h3>
                        <p>DEVICE TYPE: ${deviceType.toUpperCase()}</p>
                        <p>IP: ${deviceIP}</p>
                        <p>LOCATION: ${device.location || "N/A"}</p>
                        <p>CITY: ${city}</p>
                        <p class="device-status">Status: ${currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1)} ${statusDot.outerHTML}</p>
                        <button class="details-button" onclick="showModal('${device.cameraname || device.controllername || device.archivername || device.servername || "Unknown Device"}', '${deviceIP}', '${device.location || "N/A"}', '${currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1)}', '${city}')">Details</button>
                    `;

                    combinedDevices.push({
                        card: card,
                        device: {
                            type: deviceType,
                            status: currentStatus,
                            city: city
                        }
                    });
                });
            }

            combinedDevices.sort((a, b) => {
                const statusA = (a.device.status === "offline") ? 0 : 1;
                const statusB = (b.device.status === "offline") ? 0 : 1;
                return statusA - statusB;
            });

            const allDevices = combinedDevices.map(item => item.card);
            const deviceObjects = combinedDevices.map(item => item.device);

            citySet.forEach((city) => {
                const option = document.createElement("option");
                option.value = city;
                option.textContent = city;
                cityFilter.appendChild(option);
            });

            deviceFilter.value = "all";
            cityFilter.value = "all";
            document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
            allFilterButton.classList.add("active");

            function filterDevices() {
                const selectedType = deviceFilter.value;
                const selectedStatus = document.querySelector(".status-filter.active")?.dataset.status || "all";
                const selectedCity = cityFilter.value;

                detailsContainer.innerHTML = "";

                const filteredDevices = allDevices.filter((device) =>
                    (selectedType === "all" || device.dataset.type === selectedType) &&
                    (selectedStatus === "all" || device.dataset.status === selectedStatus) &&
                    (selectedCity === "all" || device.dataset.city === selectedCity)
                );

                filteredDevices.forEach((deviceCard) => {
                    detailsContainer.appendChild(deviceCard);
                });

                const region = currentRegion?.toUpperCase() || "GLOBAL";
                if (selectedCity !== "all") {
                    document.getElementById("region-title").textContent = `${region}, ${selectedCity} Summary`;
                } else {
                    document.getElementById("region-title").textContent = `${region} Summary`;
                }

                const filteredSummaryDevices = deviceObjects.filter((deviceObj, index) => {
                    const correspondingCard = allDevices[index];
                    return (
                        (selectedType === "all" || correspondingCard.dataset.type === selectedType) &&
                        (selectedStatus === "all" || correspondingCard.dataset.status === selectedStatus) &&
                        (selectedCity === "all" || correspondingCard.dataset.city === selectedCity)
                    );
                });

                const summary = calculateCitySummary(filteredSummaryDevices);
                updateSummary(summary);
            }

            function calculateCitySummary(devices) {
                const summary = {
                    summary: {
                        totalDevices: devices.length,
                        totalOnlineDevices: devices.filter(d => d.status === "online").length,
                        totalOfflineDevices: devices.filter(d => d.status === "offline").length,
                        cameras: { total: 0, online: 0, offline: 0 },
                        archivers: { total: 0, online: 0, offline: 0 },
                        controllers: { total: 0, online: 0, offline: 0 },
                        servers: { total: 0, online: 0, offline: 0 },
                    }
                };

                devices.forEach((device) => {
                    if (!summary.summary[device.type]) return;
                    summary.summary[device.type].total += 1;
                    if (device.status === "online") summary.summary[device.type].online += 1;
                    else summary.summary[device.type].offline += 1;
                });

                return summary;
            }

            filterDevices();

            setTimeout(() => {
                const selectedCity = cityFilter.value;
                const selectedType = deviceFilter.value;
                const selectedStatus = document.querySelector(".status-filter.active")?.dataset.status || "all";

                const filteredSummaryDevices = deviceObjects.filter((deviceObj, index) => {
                    const correspondingCard = allDevices[index];
                    return (
                        (selectedType === "all" || correspondingCard.dataset.type === selectedType) &&
                        (selectedStatus === "all" || correspondingCard.dataset.status === selectedStatus) &&
                        (selectedCity === "all" || correspondingCard.dataset.city === selectedCity)
                    );
                });

                const summary = calculateCitySummary(filteredSummaryDevices);
                updateSummary(summary);
            }, 100);

            deviceFilter.addEventListener("change", filterDevices);
            cityFilter.addEventListener("change", filterDevices);
            allFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                allFilterButton.classList.add("active");
                filterDevices();
            });
            onlineFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                onlineFilterButton.classList.add("active");
                filterDevices();
            });
            offlineFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                offlineFilterButton.classList.add("active");
                filterDevices();
            });
        })
        .catch((error) => {
            console.error("Error fetching real-time device status:", error);
            detailsContainer.innerHTML = "<p>Failed to load device details.</p>";
        });
}

function showModal(name, ip, location, status, city) {
    document.getElementById("modal-title").textContent = `Details for ${name}`;
    document.getElementById("modal-body").innerHTML = `
        <li><strong>Name:</strong> ${name}</li>
        <li><strong>IP:</strong> ${ip}</li>
        <li><strong>Location:</strong> ${location}</li>
        <li><strong>Status:</strong> ${status}</li>
        <li><strong>City:</strong> ${city}</li>
    `;
    document.getElementById("modal").style.display = "block";
}













const baseUrl = "http://localhost:80/api/regions";
let refreshInterval = 300000; // 5 minutes
let pingInterval = 30000; // 30 seconds
let countdownTime = refreshInterval / 1000; // Convert to seconds
let currentRegion = "global";
let deviceDetailsCache = {}; // Store previous details to prevent redundant updates
let latestDetails = null; // Cache the latest fetched details

document.addEventListener("DOMContentLoaded", () => {
    fetchData("global"); // Load initial data
    startAutoRefresh("global");

    document.querySelectorAll(".region-button").forEach((button) => {
        button.addEventListener("click", () => {
            const region = button.getAttribute("data-region");
            document.getElementById("region-title").textContent = `${region.toUpperCase()} Summary`;
            switchRegion(region);
        });
    });

    document.getElementById("close-modal").addEventListener("click", () => {
        document.getElementById("modal").style.display = "none";
    });
});

function switchRegion(region) {
    clearExistingIntervals(); // Avoid interval duplication
    currentRegion = region;
    deviceDetailsCache = {};
    fetchData(region);
    startAutoRefresh(region);
}

// **Auto-refresh mechanism**
function startAutoRefresh(regionName) {
    fetchData(regionName); // Fetch initial data

    clearExistingIntervals();

    // Start countdown timer
    window.countdownTimer = setInterval(() => {
        document.getElementById("countdown").innerText = `Refreshing in ${countdownTime} seconds`;
        countdownTime--;
        if (countdownTime < 0) countdownTime = refreshInterval / 1000;
    }, 1000);

    // Refresh summary & details every 5 minutes
    window.refreshTimer = setInterval(() => {
        fetchData(regionName);
        countdownTime = refreshInterval / 1000;
    }, refreshInterval);

    // Ping devices every 30 seconds using history API
    window.pingTimer = setInterval(() => {
        pingAllDevices(regionName);
    }, pingInterval);
}

function clearExistingIntervals() {
    clearInterval(window.countdownTimer);
    clearInterval(window.refreshTimer);
    clearInterval(window.pingTimer);
}

// **Fetch summary and details together**
function fetchData(regionName) {
    Promise.all([
        fetch(`${baseUrl}/summary/${regionName}`).then(res => res.json()),
        fetch(`${baseUrl}/details/${regionName}`).then(res => res.json())
    ])
    .then(([summary, details]) => {
        console.log("Summary Data:", summary);
        console.log("Details Data:", details);

        // Update summary from backend data
        updateSummary(summary);
        
        if (JSON.stringify(details) !== JSON.stringify(deviceDetailsCache)) {
            updateDetails(details);
            deviceDetailsCache = details; // Update cache
        }
        // Cache details for pinging
        latestDetails = details;
    })
    .catch((error) => console.error("Error fetching data:", error));
}

/* 
   Updated pingAllDevices:
   Instead of pinging with an incorrect API, this function now fetches the device history
   from the history API. For each device, it retrieves the most recent status from the history 
   and updates the UI accordingly.
*/
function pingAllDevices(regionName) {
    // If details parameter is not provided, use the cached latestDetails
    let details = latestDetails;
    if (!details || !details.details) return;

    fetch("http://localhost/api/devices/history")
        .then(response => response.json())
        .then(historyData => {
            let statusChanged = false; // Track if any status changed

            // Loop through each device type (cameras, archivers, etc.)
            for (const [key, devices] of Object.entries(details.details)) {
                if (!Array.isArray(devices) || devices.length === 0) continue;

                devices.forEach((device) => {
                    const ip = device.ip_address || "N/A";
                    const card = document.querySelector(`[data-ip="${ip}"]`);
                    if (!card) return; // Skip if the device UI is not found

                    // Use history API data: historyData keys are IP addresses with arrays of history entries.
                    const historyArray = historyData[ip];
                    let newStatus = (device.status || "offline").toLowerCase();
                    if (Array.isArray(historyArray) && historyArray.length > 0) {
                        // Use the status from the last history record.
                        const latestEntry = historyArray[historyArray.length - 1];
                        newStatus = (latestEntry.status || "offline").toLowerCase();
                    }
                    const currentStatus = card.dataset.status;

                    // Update UI instantly
                    const statusDot = card.querySelector(".status-dot");
                    const statusText = card.querySelector(".device-status");
                    statusDot.style.backgroundColor = (newStatus === "online") ? "green" : "red";
                    statusText.textContent = newStatus.charAt(0).toUpperCase() + newStatus.slice(1);

                    if (newStatus !== currentStatus) {
                        statusChanged = true; // A change in status was detected
                        card.dataset.status = newStatus; // Update dataset
                    }
                });
            }

            // After processing all devices, if any status changed, refresh summary
            setTimeout(() => {
                if (statusChanged) {
                    fetchData(regionName);
                }
            }, 5000); // Small delay to ensure all updates are processed
        })
        .catch(error => {
            console.error("Error fetching device history:", error);
        });
}

function updateSummary(data) {
    document.getElementById("total-devices").textContent = data.summary?.totalDevices || "0";
    document.getElementById("online-devices").textContent = data.summary?.totalOnlineDevices || "0";
    document.getElementById("offline-devices").textContent = data.summary?.totalOfflineDevices || "0";

    document.getElementById("camera-total").textContent = data.summary?.cameras?.total || "0";
    document.getElementById("camera-online").textContent = data.summary?.cameras?.online || "0";
    document.getElementById("camera-offline").textContent = data.summary?.cameras?.offline || "0";

    document.getElementById("archiver-total").textContent = data.summary?.archivers?.total || "0";
    document.getElementById("archiver-online").textContent = data.summary?.archivers?.online || "0";
    document.getElementById("archiver-offline").textContent = data.summary?.archivers?.offline || "0";

    document.getElementById("controller-total").textContent = data.summary?.controllers?.total || "0";
    document.getElementById("controller-online").textContent = data.summary?.controllers?.online || "0";
    document.getElementById("controller-offline").textContent = data.summary?.controllers?.offline || "0";

    document.getElementById("server-total").textContent = data.summary?.servers?.total || "0";
    document.getElementById("server-online").textContent = data.summary?.servers?.online || "0";
    document.getElementById("server-offline").textContent = data.summary?.servers?.offline || "0";
}

function updateDetails(data) {
    const detailsContainer = document.getElementById("device-details");
    const deviceFilter = document.getElementById("device-filter");
    const onlineFilterButton = document.getElementById("filter-online");
    const offlineFilterButton = document.getElementById("filter-offline");
    const allFilterButton = document.getElementById("filter-all");
    const cityFilter = document.getElementById("city-filter");

    detailsContainer.innerHTML = ""; // Clear previous data
    cityFilter.innerHTML = '<option value="all">All Cities</option>';

    let combinedDevices = []; // Array to hold both the card and its device info for summary
    let citySet = new Set();

    // Fetch real-time status from the backend (if available)
    fetch("http://localhost:80/api/region/devices/status")
        .then((response) => response.json())
        .then((realTimeStatus) => {
            console.log("Live Status Data:", realTimeStatus);

            for (const [key, devices] of Object.entries(data.details)) {
                if (!Array.isArray(devices) || devices.length === 0) continue;

                const deviceType = key.toLowerCase();

                devices.forEach((device) => {
                    const deviceIP = device.ip_address || "N/A";
                    // Use real-time status if available; otherwise use device.status
                    let currentStatus = (realTimeStatus[deviceIP] || device.status || "offline").toLowerCase();
                    const city = device.city || "Unknown";

                    citySet.add(city);

                    const card = document.createElement("div");
                    card.className = "device-card";
                    card.dataset.type = deviceType;
                    card.dataset.status = currentStatus;
                    card.dataset.city = city;
                    card.setAttribute("data-ip", deviceIP);

                    const statusDot = document.createElement("span");
                    statusDot.className = "status-dot";
                    statusDot.style.backgroundColor = (currentStatus === "online") ? "green" : "red";

                    card.innerHTML = `
                        <h3>${device.cameraname || device.controllername || device.archivername || device.servername || "Unknown Device"}</h3>
                        <p>DEVICE TYPE: ${deviceType.toUpperCase()}</p>
                        <p>IP: ${deviceIP}</p>
                        <p>LOCATION: ${device.location || "N/A"}</p>
                        <p>CITY: ${city}</p>
                        <p class="device-status">Status: ${currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1)} ${statusDot.outerHTML}</p>
                        <button class="details-button" onclick="showModal('${device.cameraname || device.controllername || device.archivername || device.servername || "Unknown Device"}', '${deviceIP}', '${device.location || "N/A"}', '${currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1)}', '${city}')">Details</button>
                    `;

                    combinedDevices.push({
                        card: card,
                        device: {
                            type: deviceType,
                            status: currentStatus,
                            city: city
                        }
                    });
                });
            }

            combinedDevices.sort((a, b) => {
                const statusA = (a.device.status === "offline") ? 0 : 1;
                const statusB = (b.device.status === "offline") ? 0 : 1;
                return statusA - statusB;
            });

            const allDevices = combinedDevices.map(item => item.card);
            const deviceObjects = combinedDevices.map(item => item.device);

            citySet.forEach((city) => {
                const option = document.createElement("option");
                option.value = city;
                option.textContent = city;
                cityFilter.appendChild(option);
            });

            deviceFilter.value = "all";
            cityFilter.value = "all";
            document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
            allFilterButton.classList.add("active");

            function filterDevices() {
                const selectedType = deviceFilter.value;
                const selectedStatus = document.querySelector(".status-filter.active")?.dataset.status || "all";
                const selectedCity = cityFilter.value;

                detailsContainer.innerHTML = "";

                const filteredDevices = allDevices.filter((device) =>
                    (selectedType === "all" || device.dataset.type === selectedType) &&
                    (selectedStatus === "all" || device.dataset.status === selectedStatus) &&
                    (selectedCity === "all" || device.dataset.city === selectedCity)
                );

                filteredDevices.forEach((deviceCard) => {
                    detailsContainer.appendChild(deviceCard);
                });

                const region = currentRegion?.toUpperCase() || "GLOBAL";
                if (selectedCity !== "all") {
                    document.getElementById("region-title").textContent = `${region}, ${selectedCity} Summary`;
                } else {
                    document.getElementById("region-title").textContent = `${region} Summary`;
                }

                const filteredSummaryDevices = deviceObjects.filter((deviceObj, index) => {
                    const correspondingCard = allDevices[index];
                    return (
                        (selectedType === "all" || correspondingCard.dataset.type === selectedType) &&
                        (selectedStatus === "all" || correspondingCard.dataset.status === selectedStatus) &&
                        (selectedCity === "all" || correspondingCard.dataset.city === selectedCity)
                    );
                });

                const summary = calculateCitySummary(filteredSummaryDevices);
                updateSummary(summary);
            }

            function calculateCitySummary(devices) {
                const summary = {
                    summary: {
                        totalDevices: devices.length,
                        totalOnlineDevices: devices.filter(d => d.status === "online").length,
                        totalOfflineDevices: devices.filter(d => d.status === "offline").length,
                        cameras: { total: 0, online: 0, offline: 0 },
                        archivers: { total: 0, online: 0, offline: 0 },
                        controllers: { total: 0, online: 0, offline: 0 },
                        servers: { total: 0, online: 0, offline: 0 },
                    }
                };

                devices.forEach((device) => {
                    if (!summary.summary[device.type]) return;
                    summary.summary[device.type].total += 1;
                    if (device.status === "online") summary.summary[device.type].online += 1;
                    else summary.summary[device.type].offline += 1;
                });

                return summary;
            }

            filterDevices();

            setTimeout(() => {
                const selectedCity = cityFilter.value;
                const selectedType = deviceFilter.value;
                const selectedStatus = document.querySelector(".status-filter.active")?.dataset.status || "all";

                const filteredSummaryDevices = deviceObjects.filter((deviceObj, index) => {
                    const correspondingCard = allDevices[index];
                    return (
                        (selectedType === "all" || correspondingCard.dataset.type === selectedType) &&
                        (selectedStatus === "all" || correspondingCard.dataset.status === selectedStatus) &&
                        (selectedCity === "all" || correspondingCard.dataset.city === selectedCity)
                    );
                });

                const summary = calculateCitySummary(filteredSummaryDevices);
                updateSummary(summary);
            }, 100);

            deviceFilter.addEventListener("change", filterDevices);
            cityFilter.addEventListener("change", filterDevices);
            allFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                allFilterButton.classList.add("active");
                filterDevices();
            });
            onlineFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                onlineFilterButton.classList.add("active");
                filterDevices();
            });
            offlineFilterButton.addEventListener("click", () => {
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                offlineFilterButton.classList.add("active");
                filterDevices();
            });
        })
        .catch((error) => {
            console.error("Error fetching real-time device status:", error);
            detailsContainer.innerHTML = "<p>Failed to load device details.</p>";
        });
}

function showModal(name, ip, location, status, city) {
    document.getElementById("modal-title").textContent = `Details for ${name}`;
    document.getElementById("modal-body").innerHTML = `
        <li><strong>Name:</strong> ${name}</li>
        <li><strong>IP:</strong> ${ip}</li>
        <li><strong>Location:</strong> ${location}</li>
        <li><strong>Status:</strong> ${status}</li>
        <li><strong>City:</strong> ${city}</li>
    `;
    document.getElementById("modal").style.display = "block";
}














Read Below Script.js file carefully .
now all function are Working fine 

but my console display below error

failed to load resource: the server responded with a status of 404 (Not Found)Understand this errorAI
script.js:869 Ping failed for 10.192.5.10: HTTP status 404
(anonymous) @ script.js:869Understand this errorAI
script.js:895 Ping failed for 10.192.5.10: Error: HTTP error 404
    at script.js:870:35
(anonymous) @ script.js:895Understand this errorAI
apac:1 
            
            
           Failed to load resource: the server responded with a status of 404 (Not Found)Understand this errorAI
script.js:869 Ping failed for 10.192.5.11: HTTP status 404
(anonymous) @ script.js:869Understand this errorAI
script.js:895 Ping failed for 10.192.5.11: Error: HTTP error 404
    at script.js:870:35


i mean you are using wromg api-

     // Ping the device API with enhanced error handling
                fetch(`${baseUrl}/ping/${regionName}`)
                    .then(response => {
                        if (!response.ok) {
                            console.error(`Ping failed for ${ip}: HTTP status ${response.status}`);
                            throw new Error(`HTTP error ${response.status}`);
                        }
                        return response.json().catch(err => {
                            console.error(`Ping failed for ${ip}: Response is not valid JSON`, err);
                            throw err;
                        });
                    })




Please check below APi and respomce and update this api as required.

http://localhost/api/regions/details/apac
{
  "details": {
    "cameras": [
      {
        "cameraname": "Green Zone to yellow zone passage - 10.199.10.20 (FLIR CM-3102-11-I T71552107) - 350",
        "ip_address": "10.199.10.20",
        "location": "APAC",
        "city": "Pune",
        "history": [],
        "status": "Online"
      },
      {
        "cameraname": "IN-PNQ-PF - Green Zone Exit Passage 10.199.10.139",
        "ip_address": "10.199.10.139",
        "location": "APAC",
        "city": "Pune",
        "history": [],
        "status": "Online"
      },
Same responce get for Controller, server, Archiver, 
also We can replace region name as APAC, LACA ,EMEA, NAMER

Also We have history API 

http://localhost/api/devices/history
{
  "10.199.10.20": [
    {
      "status": "Online",
      "timestamp": "2025-03-19T00:53:16.323Z"
    },
    {
      "status": "Offline",
      "timestamp": "2025-04-02T06:43:25.059Z"
    },
    {
      "status": "Online",
      "timestamp": "2025-04-02T06:45:38.535Z"


this api fetch all ip address and check their status We can alos use this api.
solve above errors and give me updated Script.js file





    const baseUrl = "http://localhost:80/api/regions";
    let refreshInterval = 300000; // 5 minutes
    let pingInterval = 30000; // 30 seconds
    let countdownTime = refreshInterval / 1000; // Convert to seconds
    let currentRegion = "global";
    let deviceDetailsCache = {}; // Store previous details to prevent redundant updates
    let latestDetails = null; // Cache the latest fetched details
    
    document.addEventListener("DOMContentLoaded", () => {
        fetchData("global"); // Load initial data
        startAutoRefresh("global");
    
        document.querySelectorAll(".region-button").forEach((button) => {
            button.addEventListener("click", () => {
                const region = button.getAttribute("data-region");
                document.getElementById("region-title").textContent = `${region.toUpperCase()} Summary`;
                switchRegion(region);
            });
        });
    
        document.getElementById("close-modal").addEventListener("click", () => {
            document.getElementById("modal").style.display = "none";
        });
    });
    
    function switchRegion(region) {
        clearExistingIntervals(); // Avoid interval duplication
        currentRegion = region;
        deviceDetailsCache = {};
        fetchData(region);
        startAutoRefresh(region);
    }
    
    // **Auto-refresh mechanism**
    function startAutoRefresh(regionName) {
        fetchData(regionName); // Fetch initial data
    
        clearExistingIntervals();
    
        // Start countdown timer
        window.countdownTimer = setInterval(() => {
            document.getElementById("countdown").innerText = `Refreshing in ${countdownTime} seconds`;
            countdownTime--;
            if (countdownTime < 0) countdownTime = refreshInterval / 1000;
        }, 1000);
    
        // Refresh summary & details every 5 minutes
        window.refreshTimer = setInterval(() => {
            fetchData(regionName);
            countdownTime = refreshInterval / 1000;
        }, refreshInterval);
    
        // Ping devices every 30 seconds
        window.pingTimer = setInterval(() => {
            pingAllDevices(regionName);
        }, pingInterval);
    }
    
    function clearExistingIntervals() {
        clearInterval(window.countdownTimer);
        clearInterval(window.refreshTimer);
        clearInterval(window.pingTimer);
    }
    
    // **Fetch summary and details together**
    function fetchData(regionName) {
        Promise.all([
            fetch(`${baseUrl}/summary/${regionName}`).then(res => res.json()),
            fetch(`${baseUrl}/details/${regionName}`).then(res => res.json())
        ])
        .then(([summary, details]) => {
            console.log("Summary Data:", summary);
            console.log("Details Data:", details);
    
            // Update summary from backend data
            updateSummary(summary);
            
            if (JSON.stringify(details) !== JSON.stringify(deviceDetailsCache)) {
                updateDetails(details);
                deviceDetailsCache = details; // Update cache
            }
            // Cache details for pinging
            latestDetails = details;
        })
        .catch((error) => console.error("Error fetching data:", error));
    }
    
    function pingAllDevices(details, regionName) {
        // If the first parameter is a string or missing, assume it is the region name
        if (!details || typeof details === "string") {
            regionName = details || regionName;
            details = latestDetails;
        }
        if (!details || !details.details) return;
    
        let statusChanged = false; // Track if any status changed
    
        for (const [key, devices] of Object.entries(details.details)) {
            if (!Array.isArray(devices) || devices.length === 0) continue;
    
            devices.forEach((device) => {
                const ip = device.ip_address || "N/A";
                const card = document.querySelector(`[data-ip="${ip}"]`);
    
                if (!card) return; // If device is not found in UI, skip
    


                
                // Ping the device API with enhanced error handling
                fetch(`${baseUrl}/ping/${regionName}`)
                    .then(response => {
                        if (!response.ok) {
                            console.error(`Ping failed for ${ip}: HTTP status ${response.status}`);
                            throw new Error(`HTTP error ${response.status}`);
                        }
                        return response.json().catch(err => {
                            console.error(`Ping failed for ${ip}: Response is not valid JSON`, err);
                            throw err;
                        });
                    })
                    .then(statusData => {
                        const newStatus = statusData.status.toLowerCase(); // Get live status
                        const currentStatus = card.dataset.status; // Current status in UI
    
                        // Update the UI instantly
                        const statusDot = card.querySelector(".status-dot");
                        const statusText = card.querySelector(".device-status");
    
                        statusDot.style.backgroundColor = (newStatus === "online") ? "green" : "red";
                        // Capitalize for display
                        statusText.textContent = newStatus.charAt(0).toUpperCase() + newStatus.slice(1);
    
                        if (newStatus !== currentStatus) {
                            statusChanged = true; // A change in status was detected
                            card.dataset.status = newStatus; // Update dataset
                        }
                    })
                    .catch(error => {
                        console.error(`Ping failed for ${ip}:`, error);
                    });
            });
        }
    
        // After processing all devices, if any status changed, refresh summary
        setTimeout(() => {
            if (statusChanged) {
                fetchData(regionName);
            }
        }, 5000); // Small delay to ensure all pings are processed
    }
    
    function updateSummary(data) {
        document.getElementById("total-devices").textContent = data.summary?.totalDevices || "0";
        document.getElementById("online-devices").textContent = data.summary?.totalOnlineDevices || "0";
        document.getElementById("offline-devices").textContent = data.summary?.totalOfflineDevices || "0";
    
        document.getElementById("camera-total").textContent = data.summary?.cameras?.total || "0";
        document.getElementById("camera-online").textContent = data.summary?.cameras?.online || "0";
        document.getElementById("camera-offline").textContent = data.summary?.cameras?.offline || "0";
    
        document.getElementById("archiver-total").textContent = data.summary?.archivers?.total || "0";
        document.getElementById("archiver-online").textContent = data.summary?.archivers?.online || "0";
        document.getElementById("archiver-offline").textContent = data.summary?.archivers?.offline || "0";
    
        document.getElementById("controller-total").textContent = data.summary?.controllers?.total || "0";
        document.getElementById("controller-online").textContent = data.summary?.controllers?.online || "0";
        document.getElementById("controller-offline").textContent = data.summary?.controllers?.offline || "0";
    
        document.getElementById("server-total").textContent = data.summary?.servers?.total || "0";
        document.getElementById("server-online").textContent = data.summary?.servers?.online || "0";
        document.getElementById("server-offline").textContent = data.summary?.servers?.offline || "0";
    }
    
    function updateDetails(data) {
        const detailsContainer = document.getElementById("device-details");
        const deviceFilter = document.getElementById("device-filter");
        const onlineFilterButton = document.getElementById("filter-online");
        const offlineFilterButton = document.getElementById("filter-offline");
        const allFilterButton = document.getElementById("filter-all");
        const cityFilter = document.getElementById("city-filter");
    
        detailsContainer.innerHTML = ""; // Clear previous data
        cityFilter.innerHTML = '<option value="all">All Cities</option>';
    
        let combinedDevices = []; // Array to hold both the card and its device info for summary
        let citySet = new Set();
    
        // Fetch real-time status from the backend
        fetch("http://localhost:80/api/region/devices/status")
            .then((response) => response.json())
            .then((realTimeStatus) => {
                console.log("Live Status Data:", realTimeStatus);
    
                for (const [key, devices] of Object.entries(data.details)) {
                    if (!Array.isArray(devices) || devices.length === 0) continue;
    
                    const deviceType = key.toLowerCase();
    
                    devices.forEach((device) => {
                        const deviceIP = device.ip_address || "N/A";
                        // Use real-time status if available; otherwise use device.status
                        let currentStatus = (realTimeStatus[deviceIP] || device.status || "offline").toLowerCase();
                        const city = device.city || "Unknown";
    
                        citySet.add(city);
    
                        const card = document.createElement("div");
                        card.className = "device-card";
                        card.dataset.type = deviceType;
                        card.dataset.status = currentStatus;
                        card.dataset.city = city;
                        card.setAttribute("data-ip", deviceIP);
    
                        const statusDot = document.createElement("span");
                        statusDot.className = "status-dot";
                        statusDot.style.backgroundColor = (currentStatus === "online") ? "green" : "red";
    
                        card.innerHTML = `
                            <h3>${device.cameraname || device.controllername || device.archivername || device.servername || "Unknown Device"}</h3>
                            <p>DEVICE TYPE: ${deviceType.toUpperCase()}</p>
                            <p>IP: ${deviceIP}</p>
                            <p>LOCATION: ${device.location || "N/A"}</p>
                            <p>CITY: ${city}</p>
                            <p class="device-status">Status: ${currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1)} ${statusDot.outerHTML}</p>
                            <button class="details-button" onclick="showModal('${device.cameraname || device.controllername || device.archivername || device.servername || "Unknown Device"}', '${deviceIP}', '${device.location || "N/A"}', '${currentStatus.charAt(0).toUpperCase() + currentStatus.slice(1)}', '${city}')">Details</button>
                        `;
    
                        combinedDevices.push({
                            card: card,
                            device: {
                                type: deviceType,
                                status: currentStatus,
                                city: city
                            }
                        });
                    });
                }
    
                combinedDevices.sort((a, b) => {
                    const statusA = (a.device.status === "offline") ? 0 : 1;
                    const statusB = (b.device.status === "offline") ? 0 : 1;
                    return statusA - statusB;
                });
    
                const allDevices = combinedDevices.map(item => item.card);
                const deviceObjects = combinedDevices.map(item => item.device);
    
                citySet.forEach((city) => {
                    const option = document.createElement("option");
                    option.value = city;
                    option.textContent = city;
                    cityFilter.appendChild(option);
                });
    
                deviceFilter.value = "all";
                cityFilter.value = "all";
                document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                allFilterButton.classList.add("active");
    
                function filterDevices() {
                    const selectedType = deviceFilter.value;
                    const selectedStatus = document.querySelector(".status-filter.active")?.dataset.status || "all";
                    const selectedCity = cityFilter.value;
    
                    detailsContainer.innerHTML = "";
    
                    const filteredDevices = allDevices.filter((device) =>
                        (selectedType === "all" || device.dataset.type === selectedType) &&
                        (selectedStatus === "all" || device.dataset.status === selectedStatus) &&
                        (selectedCity === "all" || device.dataset.city === selectedCity)
                    );
    
                    filteredDevices.forEach((deviceCard) => {
                        detailsContainer.appendChild(deviceCard);
                    });
    
                    const region = currentRegion?.toUpperCase() || "GLOBAL";
                    if (selectedCity !== "all") {
                        document.getElementById("region-title").textContent = `${region}, ${selectedCity} Summary`;
                    } else {
                        document.getElementById("region-title").textContent = `${region} Summary`;
                    }
    
                    const filteredSummaryDevices = deviceObjects.filter((deviceObj, index) => {
                        const correspondingCard = allDevices[index];
                        return (
                            (selectedType === "all" || correspondingCard.dataset.type === selectedType) &&
                            (selectedStatus === "all" || correspondingCard.dataset.status === selectedStatus) &&
                            (selectedCity === "all" || correspondingCard.dataset.city === selectedCity)
                        );
                    });
    
                    const summary = calculateCitySummary(filteredSummaryDevices);
                    updateSummary(summary);
                }
    
                function calculateCitySummary(devices) {
                    const summary = {
                        summary: {
                            totalDevices: devices.length,
                            totalOnlineDevices: devices.filter(d => d.status === "online").length,
                            totalOfflineDevices: devices.filter(d => d.status === "offline").length,
                            cameras: { total: 0, online: 0, offline: 0 },
                            archivers: { total: 0, online: 0, offline: 0 },
                            controllers: { total: 0, online: 0, offline: 0 },
                            servers: { total: 0, online: 0, offline: 0 },
                        }
                    };
    
                    devices.forEach((device) => {
                        if (!summary.summary[device.type]) return;
                        summary.summary[device.type].total += 1;
                        if (device.status === "online") summary.summary[device.type].online += 1;
                        else summary.summary[device.type].offline += 1;
                    });
    
                    return summary;
                }
    
                filterDevices();
    
                setTimeout(() => {
                    const selectedCity = cityFilter.value;
                    const selectedType = deviceFilter.value;
                    const selectedStatus = document.querySelector(".status-filter.active")?.dataset.status || "all";
    
                    const filteredSummaryDevices = deviceObjects.filter((deviceObj, index) => {
                        const correspondingCard = allDevices[index];
                        return (
                            (selectedType === "all" || correspondingCard.dataset.type === selectedType) &&
                            (selectedStatus === "all" || correspondingCard.dataset.status === selectedStatus) &&
                            (selectedCity === "all" || correspondingCard.dataset.city === selectedCity)
                        );
                    });
    
                    const summary = calculateCitySummary(filteredSummaryDevices);
                    updateSummary(summary);
                }, 100);
    
                deviceFilter.addEventListener("change", filterDevices);
                cityFilter.addEventListener("change", filterDevices);
                allFilterButton.addEventListener("click", () => {
                    document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                    allFilterButton.classList.add("active");
                    filterDevices();
                });
                onlineFilterButton.addEventListener("click", () => {
                    document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                    onlineFilterButton.classList.add("active");
                    filterDevices();
                });
                offlineFilterButton.addEventListener("click", () => {
                    document.querySelectorAll(".status-filter").forEach(btn => btn.classList.remove("active"));
                    offlineFilterButton.classList.add("active");
                    filterDevices();
                });
            })
            .catch((error) => {
                console.error("Error fetching real-time device status:", error);
                detailsContainer.innerHTML = "<p>Failed to load device details.</p>";
            });
    }
    
    function showModal(name, ip, location, status, city) {
        document.getElementById("modal-title").textContent = `Details for ${name}`;
        document.getElementById("modal-body").innerHTML = `
            <li><strong>Name:</strong> ${name}</li>
            <li><strong>IP:</strong> ${ip}</li>
            <li><strong>Location:</strong> ${location}</li>
            <li><strong>Status:</strong> ${status}</li>
            <li><strong>City:</strong> ${city}</li>
        `;
        document.getElementById("modal").style.display = "block";
    }
    
